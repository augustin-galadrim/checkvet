components: []
container:
  properties:
    html: |-
      <!-- Main button to view the queue -->
      <button class="queue-button" id="qm-viewQueueBtn">
        <span>Queue</span>
        <span class="queue-badge" id="qm-queueBadge">0</span>
      </button>

      <!-- Modal for viewing the queue -->
      <div class="modal" id="qm-queueModal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">Offline Recordings Queue</div>
          <div class="modal-body">
            <div class="queue-list" id="qm-queueListContainer">
              <!-- Queue items will be rendered here by JS -->
            </div>
          </div>
          <div class="modal-footer">
            <button class="button" id="qm-closeQueueModalBtn">Close</button>
          </div>
        </div>
      </div>

      <!-- Modal for naming a new recording before queueing -->
      <div class="modal" id="qm-titleModal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">Name Your Recording</div>
          <div class="modal-body">
            <p>Provide a title for this recording to identify it in the queue.</p>
            <label for="qm-recordingTitle">Recording Title:</label>
            <input type="text" id="qm-recordingTitle" placeholder="e.g., Exam of 'Fido'">
          </div>
          <div class="modal-footer">
            <button class="button" id="qm-cancelTitleBtn">Cancel</button>
            <button class="button button-primary" id="qm-confirmTitleBtn">Save to Queue</button>
          </div>
        </div>
      </div>

      <style>
        /* Basic styles for the button and modal, adapted from your forms */
        .queue-button { padding: 8px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px; }
        .queue-button:hover { background: #e0e0e0; }
        .queue-badge { background-color: #f44336; color: white; border-radius: 50%; padding: 2px 6px; font-size: 11px; font-weight: bold; min-width: 18px; text-align: center; display: none; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 10010; align-items: center; justify-content: center; }
        .modal-content { position: relative; background-color: white; padding: 20px; width: 90%; max-width: 500px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; }
        .modal-body p { margin-bottom: 15px; }
        .modal-body label { font-weight: bold; margin-bottom: 5px; display: block; }
        .modal-body input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; margin-bottom: 15px; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        .queue-list { max-height: 300px; overflow-y: auto; }
        .queue-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
        .queue-item:last-child { border-bottom: none; }
        .queue-item-title { font-weight: bold; }
        .queue-item-status { font-size: 12px; color: #666; margin-top: 4px; }
        .queue-item-actions button { margin-left: 10px; }
        .button { padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; cursor: pointer; }
        .button-primary { background-color: #4CAF50; color: white; border-color: #4CAF50; }
        .button[disabled] { background-color: #ccc; cursor: not-allowed; }
      </style>

      <script>
        if (!window.__queue_manager_globals) {
          window.__queue_manager_globals = true;

          let db;
          let isImportDisabled = false;

          // --- Python Callable JS Functions ---
          window.qm_initialize = function(disableImport) {
            isImportDisabled = disableImport;
            initDB().then(updateQueueBadge);
          };

          // *** NEW FUNCTION TO FIX THE ERROR ***
          window.qm_openTitleModal = function() {
            // Clear any previous input and show the modal
            const titleInput = document.getElementById('qm-recordingTitle');
            if (titleInput) titleInput.value = '';
            const modal = document.getElementById('qm-titleModal');
            if (modal) modal.style.display = 'flex';
          };

          window.qm_addToQueue = async function() {
            console.log("QM JS: addToQueue triggered. Calling back to Python to get the item...");

            try {
              // Call back to the new Python method to get the item data
              const item = await anvil.call(
                document.getElementById('qm-viewQueueBtn'), // Stable element for the call
                'get_item_to_queue'
              );

              if (!item || !item.blob || !item.title) {
                console.error("QM JS: Did not receive a valid item from Python.");
                alert("Could not retrieve the recording to be queued.");
                return;
              }

              const anvilMediaObject = item.blob;
              const title = item.title;

              console.log("QM JS: Received item from Python. Anvil Media Object:", anvilMediaObject);

              // Now, this conversion will work because anvilMediaObject was the
              // direct return value of an anvil.call.
              const jsBlob = await anvil.js.toBlob(anvilMediaObject);

              console.log("QM JS: anvil.js.toBlob successful. Resulting JS Blob:", jsBlob);

              await saveToQueue(jsBlob, title);
              await updateQueueBadge();
              anvil.call(document.getElementById('qm-viewQueueBtn'), 'handle_queue_updated');

            } catch (e) {
              console.error("QM JS: CRITICAL ERROR during queueing process:", e);
              alert("A critical error occurred while queueing the audio. Please check the browser console for details.");
            }
          };
          window.qm_refreshBadge = updateQueueBadge;


          // --- IndexedDB Core Functions ---
          function initDB() {
            return new Promise((resolve, reject) => {
              const request = indexedDB.open('audioQueueDB', 1);
              request.onerror = event => reject("IndexedDB error: " + event.target.errorCode);
              request.onsuccess = event => { db = event.target.result; resolve(db); };
              request.onupgradeneeded = event => {
                event.target.result.createObjectStore('recordings', { keyPath: 'id' });
              };
            });
          }

          async function saveToQueue(jsBlob, title) {
            if (!db) throw new Error("DB not initialized");
            const audioData = await jsBlob.arrayBuffer();
            const mimeType = jsBlob.type;
            const recording = {
              id: 'rec_' + Date.now(), title: title, audioData: audioData,
              mimeType: mimeType, status: 'queued'
            };
            return new Promise((resolve, reject) => {
              const transaction = db.transaction(['recordings'], 'readwrite');
              const store = transaction.objectStore('recordings');
              store.add(recording).onsuccess = () => resolve(recording.id);
              store.onerror = e => reject("Failed to save: " + e.target.error);
            });
          }

          function getQueuedRecordings() {
            return new Promise((resolve, reject) => {
              if (!db) return reject("DB not initialized");
              db.transaction(['recordings'], 'readonly').objectStore('recordings').getAll().onsuccess = e => resolve(e.target.result);
            });
          }

          function deleteFromQueue(id) {
            return new Promise((resolve, reject) => {
              if (!db) return reject("DB not initialized");
              db.transaction(['recordings'], 'readwrite').objectStore('recordings').delete(id).onsuccess = resolve;
            });
          }

          // --- UI and Event Handling Functions ---
          async function updateQueueBadge() {
            const queue = await getQueuedRecordings();
            const badge = document.getElementById('qm-queueBadge');
            if (badge) {
              badge.style.display = queue.length > 0 ? 'inline-block' : 'none';
              badge.textContent = queue.length;
            }
          }

          async function renderQueue() {
            const queue = await getQueuedRecordings();
            const container = document.getElementById('qm-queueListContainer');
            container.innerHTML = queue.length === 0 ? '<p>No recordings in queue.</p>' : '';

            queue.forEach(item => {
              const div = document.createElement('div');
              div.className = 'queue-item';
              const importButtonHTML = isImportDisabled
                ? `<button class="button button-primary" disabled title="Import is not available in this mode">Import</button>`
                : `<button class="button button-primary import-btn" data-id="${item.id}">Import</button>`;

              div.innerHTML = `
                <div>
                  <div class="queue-item-title">${item.title}</div>
                  <div class="queue-item-status">Status: <strong>${item.status}</strong></div>
                </div>
                <div class="queue-item-actions">
                  ${importButtonHTML}
                  <button class="button delete-btn" data-id="${item.id}">Delete</button>
                </div>`;
              container.appendChild(div);
            });
          }

          // --- Attach Event Listeners ---
          function attachQueueManagerEvents() {
            const componentRoot = document.getElementById('qm-viewQueueBtn');

            document.getElementById('qm-viewQueueBtn').addEventListener('click', async () => {
              await renderQueue();
              document.getElementById('qm-queueModal').style.display = 'flex';
            });

            document.getElementById('qm-closeQueueModalBtn').addEventListener('click', () => {
              document.getElementById('qm-queueModal').style.display = 'none';
            });

            document.getElementById('qm-queueListContainer').addEventListener('click', async (e) => {
              const target = e.target;
              const id = target.dataset.id;
              if (!id) return;

              if (target.classList.contains('import-btn')) {
                const queue = await getQueuedRecordings();
                const item = queue.find(i => i.id === id);
                if (item) {
                  const blob = new Blob([item.audioData], { type: item.mimeType });
                  anvil.call(componentRoot, 'handle_import_click', item.id, blob);
                  document.getElementById('qm-queueModal').style.display = 'none';
                }
              } else if (target.classList.contains('delete-btn')) {
                if (confirm("Are you sure you want to delete this recording?")) {
                  await deleteFromQueue(id);
                  await renderQueue(); // Re-render the list in the modal
                  await updateQueueBadge(); // Update the badge
                  anvil.call(componentRoot, 'handle_queue_updated'); // Notify parent
                }
              }
            });

            document.getElementById('qm-cancelTitleBtn').addEventListener('click', () => {
              document.getElementById('qm-titleModal').style.display = 'none';
            });

            document.getElementById('qm-confirmTitleBtn').addEventListener('click', () => {
              const title = document.getElementById('qm-recordingTitle').value.trim() || `Recording from ${new Date().toLocaleString()}`;
              anvil.call(componentRoot, 'handle_confirm_save', title);
              document.getElementById('qm-titleModal').style.display = 'none';
            });
          }

          attachQueueManagerEvents();
        }
      </script>
      </script>
  type: HtmlTemplate
custom_component: true
events:
- default_event: true
  name: x_import_item
  parameters:
  - {name: item_id}
  - {name: audio_blob}
- {name: x_queue_updated}
is_package: true
properties:
- {default_binding_prop: true, default_value: '', important: true, name: disable_import, type: string}
