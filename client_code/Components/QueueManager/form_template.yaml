components: []
container:
  properties:
    html: "<button class=\"queue-button\" id=\"queueManager-button-viewQueue\">\n  <span id=\"queueManager-span-viewQueue\">Queue</span>\n  <span class=\"queue-badge\" id=\"queueManager-span-badge\">0</span>\n</button>\n\n<!-- Modal for viewing the queue -->\n<div class=\"modal\" id=\"qm-queueModal\">\n  <div class=\"modal-content\">\n    <div class=\"modal-header\" id=\"queueManager-header-queueTitle\">Offline Recordings Queue</div>\n    <div class=\"modal-body\">\n      <div class=\"queue-list\" id=\"qm-queueListContainer\">\n        <!-- Queue items will be rendered here by JS -->\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button class=\"button\" id=\"queueManager-button-closeQueue\">Close</button>\n    </div>\n  </div>\n</div>\n\n<!-- Modal for naming a new recording before queueing -->\n<div class=\"modal\" id=\"qm-titleModal\">\n  <div class=\"modal-content\">\n    <div class=\"modal-header\" id=\"queueManager-header-nameRecordingTitle\">Name Your Recording</div>\n    <div class=\"modal-body\">\n      <p id=\"queueManager-paragraph-nameRecordingDesc\">Provide a title for this recording to identify it in the queue.</p>\n      <label for=\"queueManager-input-recordingTitle\" id=\"queueManager-label-recordingTitle\">Recording Title:</label>\n      <input type=\"text\" id=\"queueManager-input-recordingTitle\" placeholder=\"e.g., Exam of 'Fido'\">\n    </div>\n    <div class=\"modal-footer\">\n      <button class=\"button\" id=\"queueManager-button-cancelTitle\">Cancel</button>\n      <button class=\"button button-primary\" id=\"queueManager-button-confirmTitle\">Save to Queue</button>\n    </div>\n  </div>\n</div>\n\n<style>\n  .queue-button { padding: 8px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px; }\n  .queue-button:hover { background: #e0e0e0; }\n  .queue-badge { background-color: #f44336; color: white; border-radius: 50%; padding: 2px 6px; font-size: 11px; font-weight: bold; min-width: 18px; text-align: center; display: none; }\n  .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 10010; }\n  .modal-content { \n    /* This is now the main styling container inside the modal */\n    position: relative; \n    background-color: white; \n    padding: 20px; \n    width: 100%; /* Takes width from the parent .modal */\n    border-radius: 8px; \n  }  .modal-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; }\n  .modal-body p { margin-bottom: 15px; }\n  .modal-body label { font-weight: bold; margin-bottom: 5px; display: block; }\n  .modal-body input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; margin-bottom: 15px; }\n  .modal-footer { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }\n  .queue-list { max-height: 300px; overflow-y: auto; }\n  .queue-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }\n  .queue-item:last-child { border-bottom: none; }\n  .queue-item-title { font-weight: bold; }\n  .queue-item-status { font-size: 12px; color: #666; margin-top: 4px; }\n  .queue-item-actions button { margin-left: 10px; }\n  .button { padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; cursor: pointer; }\n  .button-primary { background-color: #4CAF50; color: white; border-color: #4CAF50; }\n  .button[disabled] { background-color: #ccc; cursor: not-allowed; }\n</style>\n\n<script>\n  if (!window.__queue_manager_globals) {\n    window.__queue_manager_globals = true;\n\n    const logger = window.createLogger('QueueManager');\n    let dbPromise = null;\n    let isImportDisabled = false;\n\n    window.qm_initialize = function(disableImport) {\n      isImportDisabled = disableImport;\n      initDB();\n    };\n\n    window.qm_openTitleModal = function() {\n      const titleInput = document.getElementById('queueManager-input-recordingTitle');\n      if (titleInput) titleInput.value = '';\n      window.openModal('qm-titleModal');\n    };\n\n    window.qm_addToQueue = async function(jsBlobProxy, title) {\n      try {\n        if (!jsBlobProxy || !title) {\n          logger.error(\"Did not receive a valid item to add to queue.\");\n          return;\n        }\n        await saveToQueue(jsBlobProxy, title);\n        await updateQueueBadge();\n        anvil.call(document.getElementById('queueManager-button-viewQueue'), 'handle_queue_updated');\n      } catch (e) {\n        logger.error(\"Critical error during queueing process:\", e);\n        alert(\"A critical error occurred while queueing the audio.\");\n      }\n    };\n\n    window.qm_refreshBadge = updateQueueBadge;\n\n    window.qm_deleteItem = async function(itemId) {\n      try {\n        await deleteFromQueue(itemId);\n        await updateQueueBadge();\n      } catch (e) {\n        logger.error(`Failed to delete item ${itemId}`, e);\n      }\n    };\n\n    function initDB() {\n      if (dbPromise) return dbPromise;\n      dbPromise = new Promise((resolve, reject) => {\n        const request = indexedDB.open('audioQueueDB', 1);\n        request.onerror = event => reject(\"IndexedDB error: \" + event.target.errorCode);\n        request.onsuccess = event => resolve(event.target.result);\n        request.onupgradeneeded = event => {\n          event.target.result.createObjectStore('recordings', { keyPath: 'id' });\n        };\n      });\n      return dbPromise;\n    }\n\n    async function saveToQueue(jsBlob, title) {\n      const db = await initDB();\n      const audioData = await jsBlob.arrayBuffer();\n      const mimeType = jsBlob.type;\n      const recording = {\n        id: 'rec_' + Date.now(), title: title, audioData: audioData,\n        mimeType: mimeType, status: 'queued'\n      };\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(['recordings'], 'readwrite');\n        const store = transaction.objectStore('recordings');\n        store.add(recording).onsuccess = () => resolve(recording.id);\n        store.onerror = e => reject(\"Failed to save: \" + e.target.error);\n      });\n    }\n\n    async function getQueuedRecordings() {\n      const db = await initDB();\n      return new Promise((resolve) => {\n        db.transaction(['recordings'], 'readonly').objectStore('recordings').getAll().onsuccess = e => resolve(e.target.result);\n      });\n    }\n\n    async function deleteFromQueue(id) {\n      const db = await initDB();\n      return new Promise((resolve) => {\n        db.transaction(['recordings'], 'readwrite').objectStore('recordings').delete(id).onsuccess = resolve;\n      });\n    }\n\n    async function updateQueueBadge() {\n      const queue = await getQueuedRecordings();\n      const badge = document.getElementById('queueManager-span-badge');\n      if (badge) {\n        badge.style.display = queue.length > 0 ? 'inline-block' : 'none';\n        badge.textContent = queue.length;\n      }\n    }\n\n    async function renderQueue() {\n      const queue = await getQueuedRecordings();\n      const container = document.getElementById('qm-queueListContainer');\n      const t = await anvil.call(document.getElementById('queueManager-button-viewQueue'), 'get_translations_for_renderer');\n\n      container.innerHTML = queue.length === 0 ? `<p>${t.no_recordings}</p>` : '';\n      queue.forEach(item => {\n        const div = document.createElement('div');\n        div.className = 'queue-item';\n        const importButtonHTML = isImportDisabled\n          ? `<button class=\"button button-primary\" disabled title=\"${t.import_disabled}\">${t.import_button}</button>`\n          : `<button class=\"button button-primary import-btn\" data-id=\"${item.id}\">${t.import_button}</button>`;\n        div.innerHTML = `\n          <div>\n            <div class=\"queue-item-title\">${item.title}</div>\n            <div class=\"queue-item-status\">${t.status_label} <strong>${item.status}</strong></div>\n          </div>\n          <div class=\"queue-item-actions\">\n            ${importButtonHTML}\n            <button class=\"button delete-btn\" data-id=\"${item.id}\">${t.delete_button}</button>\n          </div>`;\n        container.appendChild(div);\n      });\n    }\n\n    function attachQueueManagerEvents() {\n      const reattach = (selector, event, handler) => {\n        const element = document.querySelector(selector);\n        if (element) {\n          const newElement = element.cloneNode(true);\n          element.parentNode.replaceChild(newElement, element);\n          newElement.addEventListener(event, handler);\n        } else {\n          logger.warn(`Element with selector '${selector}' not found for event attachment.`);\n        }\n      };\n\n      reattach('#queueManager-button-viewQueue', 'click', async () => {\n        await renderQueue();\n        window.openModal('qm-queueModal');\n      });\n\n      reattach('#queueManager-button-closeQueue', 'click', () => {\n        window.closeModal('qm-queueModal');\n      });\n\n      reattach('#qm-queueListContainer', 'click', async (e) => {\n        const anvilContext = document.getElementById('queueManager-button-viewQueue');\n        if (!anvilContext) return;\n\n        const target = e.target;\n        const id = target.dataset.id;\n        if (!id) return;\n\n        if (target.classList.contains('import-btn')) {\n          const queue = await getQueuedRecordings();\n          const item = queue.find(i => i.id === id);\n          if (item) {\n            const blob = new Blob([item.audioData], { type: item.mimeType });\n            anvil.call(anvilContext, 'handle_import_click', item.id, blob);\n            window.closeModal('qm-queueModal');\n          }\n        } else if (target.classList.contains('delete-btn')) {\n          const t = await anvil.call(anvilContext, 'get_translations_for_renderer');\n          if (confirm(t.delete_confirm)) {\n            await deleteFromQueue(id);\n            await renderQueue();\n            await updateQueueBadge();\n            anvil.call(anvilContext, 'handle_queue_updated');\n          }\n        }\n      });\n\n      reattach('#queueManager-button-cancelTitle', 'click', () => {\n        window.closeModal('qm-titleModal');\n      });\n\n      reattach('#queueManager-button-confirmTitle', 'click', async () => {\n        const anvilContext = document.getElementById('queueManager-button-viewQueue');\n        if (!anvilContext) return;\n        const t = await anvil.call(anvilContext, 'get_translations_for_renderer');\n        const title = document.getElementById('queueManager-input-recordingTitle').value.trim() || `${t.default_title_prefix} ${new Date().toLocaleString()}`;\n        anvil.call(anvilContext, 'handle_confirm_save', title);\n        window.closeModal('qm-titleModal');\n      });\n    }\n\n    window.qm_reattach_events = attachQueueManagerEvents;\n    attachQueueManagerEvents();\n  }\n</script>"
  type: HtmlTemplate
custom_component: true
events:
- default_event: true
  name: x_import_item
  parameters:
  - {name: item_id}
  - {name: audio_blob}
- {name: x_queue_updated}
is_package: true
properties:
- {default_binding_prop: true, default_value: false, important: true, name: disable_import, type: boolean}
