components: []
container:
  properties:
    html: |-
      <button class="queue-button" id="queueManager-button-viewQueue">
        <span id="queueManager-span-viewQueue">Queue</span>
        <span class="queue-badge" id="queueManager-span-badge">0</span>
      </button>

      <!-- Modal for viewing the queue -->
      <div class="modal" id="qm-queueModal">
        <div class="modal-content">
          <div class="modal-header" id="queueManager-header-queueTitle">Offline Recordings Queue</div>
          <div class="modal-body">
            <div class="queue-list" id="qm-queueListContainer">
              <!-- Queue items will be rendered here by JS -->
            </div>
          </div>
          <div class="modal-footer">
            <button class="button" id="queueManager-button-closeQueue">Close</button>
          </div>
        </div>
      </div>

      <!-- Modal for naming a new recording before queueing -->
      <div class="modal" id="qm-titleModal">
        <div class="modal-content">
          <div class="modal-header" id="queueManager-header-nameRecordingTitle">Name Your Recording</div>
          <div class="modal-body">
            <p id="queueManager-paragraph-nameRecordingDesc">Provide a title for this recording to identify it in the queue.</p>
            <label for="queueManager-input-recordingTitle" id="queueManager-label-recordingTitle">Recording Title:</label>
            <input type="text" id="queueManager-input-recordingTitle" placeholder="e.g., Exam of 'Fido'">
          </div>
          <div class="modal-footer">
            <button class="button" id="queueManager-button-cancelTitle">Cancel</button>
            <button class="button button-primary" id="queueManager-button-confirmTitle">Save to Queue</button>
          </div>
        </div>
      </div>

      <style>
        .queue-button { padding: 8px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px; }
        .queue-button:hover { background: #e0e0e0; }
        .queue-badge { background-color: #f44336; color: white; border-radius: 50%; padding: 2px 6px; font-size: 11px; font-weight: bold; min-width: 18px; text-align: center; display: none; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 10010; }
        .modal-content { position: relative; background-color: white; padding: 20px; width: 90%; max-width: 500px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; }
        .modal-body p { margin-bottom: 15px; }
        .modal-body label { font-weight: bold; margin-bottom: 5px; display: block; }
        .modal-body input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; margin-bottom: 15px; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        .queue-list { max-height: 300px; overflow-y: auto; }
        .queue-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
        .queue-item:last-child { border-bottom: none; }
        .queue-item-title { font-weight: bold; }
        .queue-item-status { font-size: 12px; color: #666; margin-top: 4px; }
        .queue-item-actions button { margin-left: 10px; }
        .button { padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; cursor: pointer; }
        .button-primary { background-color: #4CAF50; color: white; border-color: #4CAF50; }
        .button[disabled] { background-color: #ccc; cursor: not-allowed; }
      </style>

      <script>
        if (!window.__queue_manager_globals) {
          window.__queue_manager_globals = true;

          const logger = window.createLogger('QueueManager');
          let dbPromise = null;
          let isImportDisabled = false;

          window.qm_initialize = function(disableImport) {
            isImportDisabled = disableImport;
            initDB();
          };

          window.qm_openTitleModal = function() {
            const titleInput = document.getElementById('queueManager-input-recordingTitle');
            if (titleInput) titleInput.value = '';
            window.openModal('qm-titleModal');
          };

          window.qm_addToQueue = async function(jsBlobProxy, title) {
            try {
              if (!jsBlobProxy || !title) {
                logger.error("Did not receive a valid item to add to queue.");
                return;
              }
              await saveToQueue(jsBlobProxy, title);
              await updateQueueBadge();
              anvil.call(document.getElementById('queueManager-button-viewQueue'), 'handle_queue_updated');
            } catch (e) {
              logger.error("Critical error during queueing process:", e);
              alert("A critical error occurred while queueing the audio.");
            }
          };

          window.qm_refreshBadge = updateQueueBadge;

          window.qm_deleteItem = async function(itemId) {
            try {
              await deleteFromQueue(itemId);
              await updateQueueBadge();
            } catch (e) {
              logger.error(`Failed to delete item ${itemId}`, e);
            }
          };

          function initDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
              const request = indexedDB.open('audioQueueDB', 1);
              request.onerror = event => reject("IndexedDB error: " + event.target.errorCode);
              request.onsuccess = event => resolve(event.target.result);
              request.onupgradeneeded = event => {
                event.target.result.createObjectStore('recordings', { keyPath: 'id' });
              };
            });
            return dbPromise;
          }

          async function saveToQueue(jsBlob, title) {
            const db = await initDB();
            const audioData = await jsBlob.arrayBuffer();
            const mimeType = jsBlob.type;
            const recording = {
              id: 'rec_' + Date.now(), title: title, audioData: audioData,
              mimeType: mimeType, status: 'queued'
            };
            return new Promise((resolve, reject) => {
              const transaction = db.transaction(['recordings'], 'readwrite');
              const store = transaction.objectStore('recordings');
              store.add(recording).onsuccess = () => resolve(recording.id);
              store.onerror = e => reject("Failed to save: " + e.target.error);
            });
          }

          async function getQueuedRecordings() {
            const db = await initDB();
            return new Promise((resolve) => {
              db.transaction(['recordings'], 'readonly').objectStore('recordings').getAll().onsuccess = e => resolve(e.target.result);
            });
          }

          async function deleteFromQueue(id) {
            const db = await initDB();
            return new Promise((resolve) => {
              db.transaction(['recordings'], 'readwrite').objectStore('recordings').delete(id).onsuccess = resolve;
            });
          }

          async function updateQueueBadge() {
            const queue = await getQueuedRecordings();
            const badge = document.getElementById('queueManager-span-badge');
            if (badge) {
              badge.style.display = queue.length > 0 ? 'inline-block' : 'none';
              badge.textContent = queue.length;
            }
          }

          async function renderQueue() {
            const queue = await getQueuedRecordings();
            const container = document.getElementById('qm-queueListContainer');
            const t = await anvil.call(document.getElementById('queueManager-button-viewQueue'), 'get_translations_for_renderer');

            container.innerHTML = queue.length === 0 ? `<p>${t.no_recordings}</p>` : '';
            queue.forEach(item => {
              const div = document.createElement('div');
              div.className = 'queue-item';
              const importButtonHTML = isImportDisabled
                ? `<button class="button button-primary" disabled title="${t.import_disabled}">${t.import_button}</button>`
                : `<button class="button button-primary import-btn" data-id="${item.id}">${t.import_button}</button>`;
              div.innerHTML = `
                <div>
                  <div class="queue-item-title">${item.title}</div>
                  <div class="queue-item-status">${t.status_label} <strong>${item.status}</strong></div>
                </div>
                <div class="queue-item-actions">
                  ${importButtonHTML}
                  <button class="button delete-btn" data-id="${item.id}">${t.delete_button}</button>
                </div>`;
              container.appendChild(div);
            });
          }

          function attachQueueManagerEvents() {
            const reattach = (selector, event, handler) => {
              const element = document.querySelector(selector);
              if (element) {
                const newElement = element.cloneNode(true);
                element.parentNode.replaceChild(newElement, element);
                newElement.addEventListener(event, handler);
              } else {
                logger.warn(`Element with selector '${selector}' not found for event attachment.`);
              }
            };

            reattach('#queueManager-button-viewQueue', 'click', async () => {
              await renderQueue();
              window.openModal('qm-queueModal');
            });

            reattach('#queueManager-button-closeQueue', 'click', () => {
              window.closeModal('qm-queueModal');
            });

            reattach('#qm-queueListContainer', 'click', async (e) => {
              const anvilContext = document.getElementById('queueManager-button-viewQueue');
              if (!anvilContext) return;

              const target = e.target;
              const id = target.dataset.id;
              if (!id) return;

              if (target.classList.contains('import-btn')) {
                const queue = await getQueuedRecordings();
                const item = queue.find(i => i.id === id);
                if (item) {
                  const blob = new Blob([item.audioData], { type: item.mimeType });
                  anvil.call(anvilContext, 'handle_import_click', item.id, blob);
                  window.closeModal('qm-queueModal');
                }
              } else if (target.classList.contains('delete-btn')) {
                const t = await anvil.call(anvilContext, 'get_translations_for_renderer');
                if (confirm(t.delete_confirm)) {
                  await deleteFromQueue(id);
                  await renderQueue();
                  await updateQueueBadge();
                  anvil.call(anvilContext, 'handle_queue_updated');
                }
              }
            });

            reattach('#queueManager-button-cancelTitle', 'click', () => {
              window.closeModal('qm-titleModal');
            });

            reattach('#queueManager-button-confirmTitle', 'click', async () => {
              const anvilContext = document.getElementById('queueManager-button-viewQueue');
              if (!anvilContext) return;
              const t = await anvil.call(anvilContext, 'get_translations_for_renderer');
              const title = document.getElementById('queueManager-input-recordingTitle').value.trim() || `${t.default_title_prefix} ${new Date().toLocaleString()}`;
              anvil.call(anvilContext, 'handle_confirm_save', title);
              window.closeModal('qm-titleModal');
            });
          }

          window.qm_reattach_events = attachQueueManagerEvents;
          attachQueueManagerEvents();
        }
      </script>
  type: HtmlTemplate
custom_component: true
events:
- default_event: true
  name: x_import_item
  parameters:
  - {name: item_id}
  - {name: audio_blob}
- {name: x_queue_updated}
is_package: true
properties:
- {default_binding_prop: true, default_value: false, important: true, name: disable_import, type: boolean}
