components: []
container:
  properties:
    html: |-
      <!-- Main button to view the queue -->
      <button class="queue-button" id="qm-viewQueueBtn">
        <span>Queue</span>
        <span class="queue-badge" id="qm-queueBadge">0</span>
      </button>

      <!-- Modal for viewing the queue -->
      <div class="modal" id="qm-queueModal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">Offline Recordings Queue</div>
          <div class="modal-body">
            <div class="queue-list" id="qm-queueListContainer">
              <!-- Queue items will be rendered here by JS -->
            </div>
          </div>
          <div class="modal-footer">
            <button class="button" id="qm-closeQueueModalBtn">Close</button>
          </div>
        </div>
      </div>

      <!-- Modal for naming a new recording before queueing -->
      <div class="modal" id="qm-titleModal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">Name Your Recording</div>
          <div class="modal-body">
            <p>Provide a title for this recording to identify it in the queue.</p>
            <label for="qm-recordingTitle">Recording Title:</label>
            <input type="text" id="qm-recordingTitle" placeholder="e.g., Exam of 'Fido'">
          </div>
          <div class="modal-footer">
            <button class="button" id="qm-cancelTitleBtn">Cancel</button>
            <button class="button button-primary" id="qm-confirmTitleBtn">Save to Queue</button>
          </div>
        </div>
      </div>

      <style>
        /* Basic styles for the button and modal, adapted from your forms */
        .queue-button { padding: 8px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px; }
        .queue-button:hover { background: #e0e0e0; }
        .queue-badge { background-color: #f44336; color: white; border-radius: 50%; padding: 2px 6px; font-size: 11px; font-weight: bold; min-width: 18px; text-align: center; display: none; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 10010; align-items: center; justify-content: center; }
        .modal-content { position: relative; background-color: white; padding: 20px; width: 90%; max-width: 500px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; }
        .modal-body p { margin-bottom: 15px; }
        .modal-body label { font-weight: bold; margin-bottom: 5px; display: block; }
        .modal-body input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; margin-bottom: 15px; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        .queue-list { max-height: 300px; overflow-y: auto; }
        .queue-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
        .queue-item:last-child { border-bottom: none; }
        .queue-item-title { font-weight: bold; }
        .queue-item-status { font-size: 12px; color: #666; margin-top: 4px; }
        .queue-item-actions button { margin-left: 10px; }
        .button { padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; cursor: pointer; }
        .button-primary { background-color: #4CAF50; color: white; border-color: #4CAF50; }
        .button[disabled] { background-color: #ccc; cursor: not-allowed; }
      </style>

      <script>
        if (!window.__queue_manager_globals) {
          window.__queue_manager_globals = true;

          let db;
          let isImportDisabled = false; // This will be set by Python

          // Function to be called from Python to set the initial state
          window.qm_initialize = function(disableImport) {
            isImportDisabled = disableImport;
            initDB().then(updateQueueBadge);
          };

          // --- IndexedDB Core Functions ---
          function initDB() {
            return new Promise((resolve, reject) => {
              const request = indexedDB.open('audioQueueDB', 1);
              request.onerror = event => reject("IndexedDB error: " + event.target.errorCode);
              request.onsuccess = event => { db = event.target.result; resolve(db); };
              request.onupgradeneeded = event => {
                event.target.result.createObjectStore('recordings', { keyPath: 'id' });
              };
            });
          }

          async function saveToQueue(audioBlob, title) {
            if (!db) throw new Error("DB not initialized");
            const audioData = await audioBlob.arrayBuffer();
            const mimeType = audioBlob.type;
            const recording = {
              id: 'rec_' + Date.now(), title: title, audioData: audioData,
              mimeType: mimeType, status: 'queued'
            };
            return new Promise((resolve, reject) => {
              const transaction = db.transaction(['recordings'], 'readwrite');
              const store = transaction.objectStore('recordings');
              store.add(recording).onsuccess = () => resolve(recording.id);
              store.onerror = e => reject("Failed to save: " + e.target.error);
            });
          }

          function getQueuedRecordings() {
            return new Promise((resolve, reject) => {
              if (!db) return reject("DB not initialized");
              const store = db.transaction(['recordings'], 'readonly').objectStore('recordings');
              store.getAll().onsuccess = e => resolve(e.target.result);
            });
          }

          function deleteFromQueue(id) {
            return new Promise((resolve, reject) => {
              if (!db) return reject("DB not initialized");
              db.transaction(['recordings'], 'readwrite').objectStore('recordings').delete(id).onsuccess = resolve;
            });
          }

          // --- UI and Event Handling Functions ---
          async function updateQueueBadge() {
            const queue = await getQueuedRecordings();
            const badge = document.getElementById('qm-queueBadge');
            if (badge) {
              badge.style.display = queue.length > 0 ? 'inline-block' : 'none';
              badge.textContent = queue.length;
            }
          }

          async function renderQueue() {
            const queue = await getQueuedRecordings();
            const container = document.getElementById('qm-queueListContainer');
            container.innerHTML = queue.length === 0 ? '<p>No recordings in queue.</p>' : '';

            queue.forEach(item => {
              const div = document.createElement('div');
              div.className = 'queue-item';
              const importButtonHTML = isImportDisabled
                ? `<button class="button button-primary" disabled title="Import is not available in offline mode">Import</button>`
                : `<button class="button button-primary import-btn" data-id="${item.id}">Import</button>`;

              div.innerHTML = `
              <div>
                <div class="queue-item-title">${item.title}</div>
                <div class="queue-item-status">Status: <strong>${item.status}</strong></div>
              </div>
              <div class="queue-item-actions">
                ${importButtonHTML}
                <button class="button delete-btn" data-id="${item.id}">Delete</button>
              </div>`;
              container.appendChild(div);
            });
          }

          // Public function for parent form to call
          window.qm_addToQueue = async function(audioBlob, title) {
            await saveToQueue(audioBlob, title);
            await updateQueueBadge();
            anvil.call(document.getElementById('qm-viewQueueBtn'), 'handle_queue_updated');
          };

          window.qm_refreshBadge = updateQueueBadge;

          // --- Attach Event Listeners ---
          function attachQueueManagerEvents() {
            const componentRoot = document.getElementById('qm-viewQueueBtn');

            // Main button to open the modal
            document.getElementById('qm-viewQueueBtn').addEventListener('click', async () => {
              await renderQueue();
              document.getElementById('qm-queueModal').style.display = 'flex';
            });

            // Close modal button
            document.getElementById('qm-closeQueueModalBtn').addEventListener('click', () => {
              document.getElementById('qm-queueModal').style.display = 'none';
            });

            // Event delegation for import/delete buttons inside the modal
            document.getElementById('qm-queueListContainer').addEventListener('click', async (e) => {
              const target = e.target;
              const id = target.dataset.id;
              if (!id) return;

              if (target.classList.contains('import-btn')) {
                const queue = await getQueuedRecordings();
                const item = queue.find(i => i.id === id);
                if (item) {
                  const blob = new Blob([item.audioData], { type: item.mimeType });
                  // Call back to Python to raise the event
                  anvil.call(componentRoot, 'handle_import_click', item.id, blob);
                  document.getElementById('qm-queueModal').style.display = 'none';
                }
              } else if (target.classList.contains('delete-btn')) {
                // Call back to Python to handle deletion
                anvil.call(componentRoot, 'handle_delete_click', id);
              }
            });

            // --- Title Modal Logic ---
            document.getElementById('qm-cancelTitleBtn').addEventListener('click', () => {
              document.getElementById('qm-titleModal').style.display = 'none';
            });

            document.getElementById('qm-confirmTitleBtn').addEventListener('click', () => {
              const title = document.getElementById('qm-recordingTitle').value.trim();
              anvil.call(componentRoot, 'handle_confirm_save', title);
              document.getElementById('qm-titleModal').style.display = 'none';
            });
          }

          attachQueueManagerEvents();
        }
      </script>
      </script>
  type: HtmlTemplate
custom_component: true
events:
- default_event: true
  name: x_import_item
  parameters:
  - {name: item_id}
  - {name: audio_blob}
- {name: x_queue_updated}
is_package: true
properties:
- {default_binding_prop: true, default_value: '', important: true, name: disable_import, type: string}
