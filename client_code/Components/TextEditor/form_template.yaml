components: []
container:
  properties:
    html: |-
      <div class="editor-section">
        <style>
          .editor-section { background: #fff; border-radius: 8px; overflow: hidden; border: 1px solid #ddd; }
          #toolbar { padding: 10px; background: #f8f8f8; border-bottom: 1px solid #ddd; display: flex; flex-wrap: wrap; gap: 5px; align-items: center; }
          .toolbar-button { padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; background: #fff; cursor: pointer; }
          .toolbar-button:hover { background: #f5f5f5; }
          .toolbar-button.active { background-color: #d0ebff; border-color: #66b0ff; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
          .toolbar-button svg { vertical-align: middle; }
          #editor { min-height: 300px; padding: 20px; overflow-y: auto; font-size: 16px; line-height: 1.5; }
          #editor p, #editor div { margin: 0; }
          .toolbar-group { display: inline-flex; gap: 5px; }
          .toolbar-button.disabled { background-color: #cccccc; color: #666666; cursor: not-allowed; pointer-events: none; border-color: #bbbbbb; }
          .toolbar-button.disabled:hover { background-color: #cccccc; border-color: #bbbbbb; }
        </style>

        <div id="toolbar">
          <div id="undoRedoButtons" class="toolbar-group">
            <button id="undoBtn" class="toolbar-button" title="Undo">↩️</button>
            <button id="redoBtn" class="toolbar-button" title="Redo">↪️</button>
          </div>
          <div id="styleButtons" class="toolbar-group">
            <button id="format-bold-btn" class="toolbar-button"><b>B</b></button>
            <button id="format-italic-btn" class="toolbar-button"><i>I</i></button>
            <button id="format-underline-btn" class="toolbar-button"><u>U</u></button>
          </div>
          <div id="alignButtons" class="toolbar-group">
            <button id="align-left-btn" class="toolbar-button" title="Align Left"><svg width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M1 3h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm0 4h10a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm0 4h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2z"/></svg></button>
            <button id="align-center-btn" class="toolbar-button" title="Align Center"><svg width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M3 3h10a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm-2 4h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm2 4h10a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2z"/></svg></button>
            <button id="align-right-btn" class="toolbar-button" title="Align Right"><svg width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M5 3h10a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zM1 7h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm4 4h10a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2z"/></svg></button>
          </div>
          <button id="insertImageBtn" class="toolbar-button disabled">Image</button>
          <span style="margin-left:auto;"></span>
          <button id="copyBtn" class="toolbar-button">Copy</button>
        </div>
        <div id="editor" contenteditable="true"></div>
      </div>

      <script>
        // Use a guard to ensure function definitions are only loaded once per page.
        if (!window.__editor_component_globals) {
          window.__editor_component_globals = true;
          console.log("DEBUG: TextEditor JS -> Defining global functions for the first time.");

          // --- Python-Callable Functions (Component's Public JS API) ---
          window.getEditorContent = function() {
            const editor = document.getElementById("editor");
            return editor ? editor.innerHTML : "";
          };

          window.setEditorContent = function(value) {
            const editor = document.getElementById("editor");
            if (editor) {
              if (value && !value.startsWith('<')) {
                editor.innerHTML = `<div>${value.replace(/\\n/g, '</div><div>')}</div>`;
              } else {
                editor.innerHTML = value || "";
              }
            }
          };

          window.setElementVisibility = function(id, isVisible) {
            const elem = document.getElementById(id);
            if (elem) elem.style.display = isVisible ? '' : 'none';
          };

          window.setButtonEnabled = function(buttonId, isEnabled) {
            const button = document.getElementById(buttonId);
            if (button) {
              button.disabled = !isEnabled;
              button.classList.toggle('disabled', !isEnabled);
            }
          };

          // --- Internal Helper Functions & Event Handlers ---
          window.applyAlignment = function(align) {
            const editor = document.getElementById("editor");
            if (!editor) return;
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            let node = selection.anchorNode;
            if (!node) return;
            while (node && node !== editor) {
              if (node.nodeType === Node.ELEMENT_NODE && ['DIV', 'P'].includes(node.tagName.toUpperCase())) {
                node.style.textAlign = align;
                return;
              }
              node = node.parentNode;
            }
            document.execCommand('formatBlock', false, 'div');
            const newBlock = window.getSelection().anchorNode.parentNode;
            if (newBlock && newBlock.style) {
              newBlock.style.textAlign = align;
            }
          };

          window.insertImage = function() {
            const button = document.getElementById("insertImageBtn");
            if (button && button.classList.contains("disabled")) { return; }
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*";
            input.onchange = function(e) {
              const file = e.target.files[0];
              if (!file) return;
              const reader = new FileReader();
              reader.onload = function(evt) {
                const img = document.createElement("img");
                img.src = evt.target.result;
                img.style.maxWidth = "100%";
                img.dataset.referenceId = "img_" + Date.now();
                const editorEl = document.getElementById("editor");
                if (editorEl) editorEl.appendChild(img);
              };
              reader.readAsDataURL(file);
            };
            input.click();
          };

          window.copyEditorContent = function() {
            const editor = document.getElementById("editor");
            if (!editor) return;
            const range = document.createRange();
            range.selectNodeContents(editor);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            try {
              document.execCommand("copy");
              alert("Content copied!");
            } catch (err) {
              console.error("Error copying =>", err);
            }
            sel.removeAllRanges();
          };

          window.updateToolbarState = function() {
            const simpleCommands = {
              'format-bold-btn': 'bold',
              'format-italic-btn': 'italic',
              'format-underline-btn': 'underline'
            };
            for (const [buttonId, command] of Object.entries(simpleCommands)) {
              const button = document.getElementById(buttonId);
              if (button) {
                try {
                  const isActive = document.queryCommandState(command);
                  button.classList.toggle('active', isActive);
                } catch (e) { /* Fails in some edge cases, ignore */ }
              }
            }
            let alignment = 'left';
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
              let node = selection.anchorNode;
              const editor = document.getElementById('editor');
              while (node && node !== editor) {
                if (node.nodeType === Node.ELEMENT_NODE && node.style.textAlign) {
                  alignment = node.style.textAlign;
                  break;
                }
                node = node.parentNode;
              }
            }
            const leftBtn = document.getElementById('align-left-btn');
            const centerBtn = document.getElementById('align-center-btn');
            const rightBtn = document.getElementById('align-right-btn');
            if (leftBtn) leftBtn.classList.toggle('active', alignment === 'left' || alignment === '');
            if (centerBtn) centerBtn.classList.toggle('active', alignment === 'center');
            if (rightBtn) rightBtn.classList.toggle('active', alignment === 'right');
          };

          // --- THE SINGLE, ROBUST INITIALIZATION FUNCTION (Called from Python) ---
          window.initializeEditor = function(retryCount = 0) {
            console.log("DEBUG: TextEditor JS -> initializeEditor() called.");
            const editorDiv = document.getElementById('editor');
            if (!editorDiv) {
              if (retryCount < 20) {
                console.warn(`DEBUG: TextEditor JS -> #editor element not found. Retrying... (Attempt ${retryCount + 1})`);
                setTimeout(() => window.initializeEditor(retryCount + 1), 50);
              } else {
                console.error("TextEditor Fatal Error: #editor element not found after multiple retries.");
              }
              return;
            }
            console.log("DEBUG: TextEditor JS -> #editor element found. Attaching listeners.");

            const addButtonListener = (buttonId, handler) => {
              const button = document.getElementById(buttonId);
              if (button) {
                console.log(`DEBUG: TextEditor JS -> Attaching listener to #${buttonId}`);
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
                newButton.addEventListener('mousedown', (event) => {
                  event.preventDefault();
                  if (!newButton.disabled) { handler(); }
                });
              } else {
                console.warn(`DEBUG: TextEditor JS -> Button #${buttonId} not found.`);
              }
            };

            addButtonListener('undoBtn', () => anvil.call(editorDiv.closest('.anvil-container'), 'undo_change'));
            addButtonListener('redoBtn', () => anvil.call(editorDiv.closest('.anvil-container'), 'redo_change'));
            addButtonListener('format-bold-btn', () => { document.execCommand('bold', false, null); window.updateToolbarState(); });
            addButtonListener('format-italic-btn', () => { document.execCommand('italic', false, null); window.updateToolbarState(); });
            addButtonListener('format-underline-btn', () => { document.execCommand('underline', false, null); window.updateToolbarState(); });
            addButtonListener('align-left-btn', () => { window.applyAlignment('left'); window.updateToolbarState(); });
            addButtonListener('align-center-btn', () => { window.applyAlignment('center'); window.updateToolbarState(); });
            addButtonListener('align-right-btn', () => { window.applyAlignment('right'); window.updateToolbarState(); });
            addButtonListener('copyBtn', window.copyEditorContent);
            addButtonListener('insertImageBtn', window.insertImage);

            if (!editorDiv.dataset.stateListenersAttached) {
              editorDiv.dataset.stateListenersAttached = 'true';
              editorDiv.addEventListener('mouseup', window.updateToolbarState);
              editorDiv.addEventListener('keyup', window.updateToolbarState);
              editorDiv.addEventListener('focus', window.updateToolbarState);
            }

            if (!editorDiv.dataset.blurAttached) {
              editorDiv.dataset.blurAttached = 'true';
              editorDiv.addEventListener('blur', () => {
                anvil.call(editorDiv.closest('.anvil-container'), 'on_blur_handler');
              });
            }
          };
        }
        console.log("DEBUG: TextEditor JS -> Script block loaded. Initialization will be triggered by Python.");
      </script>
  type: HtmlTemplate
custom_component: true
is_package: true
properties:
- {default_binding_prop: true, default_value: true, important: true, name: show_image_button, type: boolean}
- {default_value: true, important: true, name: show_style_buttons, type: boolean}
- {default_value: true, important: true, name: show_copy_button, type: boolean}
- {default_value: true, important: true, name: show_align_buttons, type: boolean}
- {default_value: false, important: true, name: show_undo_redo_buttons, type: boolean}
