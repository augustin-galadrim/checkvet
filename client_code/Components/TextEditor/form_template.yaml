components: []
container:
  properties:
    html: |-
      <div class="editor-section">
        <style>
          .editor-section { background: #fff; border-radius: 8px; overflow: hidden; border: 1px solid #ddd; }
          #toolbar { padding: 10px; background: #f8f8f8; border-bottom: 1px solid #ddd; display: flex; flex-wrap: wrap; gap: 5px; align-items: center; }
          .toolbar-button { padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; background: #fff; cursor: pointer; }
          .toolbar-button:hover { background: #f5f5f5; }
          .toolbar-button svg { vertical-align: middle; } /* Styling for icons */
          #editor { min-height: 300px; padding: 20px; overflow-y: auto; font-size: 16px; line-height: 1.5; }
          #editor p, #editor div { margin: 0; } /* Ensure no default margins on blocks */
          .toolbar-group { display: inline-flex; gap: 5px; }
          .toolbar-button.disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            pointer-events: none;
            border-color: #bbbbbb;
          }

          .toolbar-button.disabled:hover {
            background-color: #cccccc;
            border-color: #bbbbbb;
          }
        </style>

        <div id="toolbar">
          <div id="styleButtons" class="toolbar-group">
            <button class="toolbar-button" onclick="formatDoc('bold')"><b>B</b></button>
            <button class="toolbar-button" onclick="formatDoc('italic')"><i>I</i></button>
            <button class="toolbar-button" onclick="formatDoc('underline')"><u>U</u></button>
          </div>
          <div id="alignButtons" class="toolbar-group">
            <!-- MODIFICATION: Changed onclick to call the new applyAlignment function -->
            <button class="toolbar-button" onclick="applyAlignment('left')" title="Align Left">
              <svg width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M1 3h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm0 4h10a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm0 4h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2z"/></svg>
            </button>
            <button class="toolbar-button" onclick="applyAlignment('center')" title="Align Center">
              <svg width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M3 3h10a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm-2 4h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm2 4h10a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2z"/></svg>
            </button>
            <button class="toolbar-button" onclick="applyAlignment('right')" title="Align Right">
              <svg width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M5 3h10a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zM1 7h14a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm4 4h10a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2z"/></svg>
            </button>
          </div>
          <button id="insertImageBtn" class="toolbar-button disabled" onclick="insertImage()">Image</button>
          <span style="margin-left:auto;"></span>
          <button id="copyBtn" class="toolbar-button" onclick="copyEditorContent()">Copy</button>
        </div>
        <div id="editor" contenteditable="true"></div>
      </div>

      <script>
        if (!window.__editor_component_globals) {
          window.__editor_component_globals = true;

          // Python-Callable Functions
          window.getEditorContent = function() {
            const editor = document.getElementById("editor");
            return editor ? editor.innerHTML : "";
          };

          window.setEditorContent = function(value) {
            const editor = document.getElementById("editor");
            if (editor) {
              // Ensure default content is wrapped in block elements for consistent behavior
              if (value && !value.startsWith('<')) {
                editor.innerHTML = `<div>${value.replace(/\\n/g, '</div><div>')}</div>`;
              } else {
                editor.innerHTML = value || "";
              }
            }
          };

          window.setElementVisibility = function(id, isVisible) {
            const elem = document.getElementById(id);
            if (elem) elem.style.display = isVisible ? '' : 'none';
          };

          // Helper Functions
          window.formatDoc = function(cmd) {
            document.execCommand(cmd, false, null);
          };

          // MODIFICATION: Added new, more precise alignment function
          window.applyAlignment = function(align) {
            const editor = document.getElementById("editor");
            if (!editor) return;

            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            let node = selection.anchorNode;
            if (!node) return;

            // Find the block-level element (P or DIV) that contains the current selection
            while (node && node !== editor) {
              if (node.nodeType === Node.ELEMENT_NODE && ['DIV', 'P'].includes(node.tagName.toUpperCase())) {
                // Apply the style directly to the block element and stop
                node.style.textAlign = align;
                return;
              }
              node = node.parentNode;
            }

            // Fallback: if no block element is found, wrap the current line in a DIV and apply the style.
            // This handles cases where the text is not already in a block.
            document.execCommand('formatBlock', false, 'div');

            // Get the newly created div and apply the alignment.
            const newBlock = window.getSelection().anchorNode.parentNode;
            if(newBlock && newBlock.style) {
              newBlock.style.textAlign = align;
            }
          };

          window.insertImage = function() {
            const button = document.getElementById("insertImageBtn");
            if (button && button.classList.contains("disabled")) {
              return;
            }
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*";
            input.onchange = function(e) {
              const file = e.target.files[0];
              if (!file) return;
              const reader = new FileReader();
              reader.onload = function(evt) {
                const img = document.createElement("img");
                img.src = evt.target.result;
                img.style.maxWidth = "100%";
                img.dataset.referenceId = "img_" + Date.now();
                const editorEl = document.getElementById("editor");
                if (editorEl) editorEl.appendChild(img);
              };
              reader.readAsDataURL(file);
            };
            input.click();
          };

          window.copyEditorContent = function() {
            const editor = document.getElementById("editor");
            if (!editor) return;
            const range = document.createRange();
            range.selectNodeContents(editor);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            try {
              document.execCommand("copy");
              alert("Content copied!");
            } catch (err) {
              console.error("Error copying =>", err);
            }
            sel.removeAllRanges();
          };
        }
      </script>
  type: HtmlTemplate
custom_component: true
is_package: true
properties:
- {default_binding_prop: true, default_value: true, important: true, name: show_image_button, type: boolean}
- {default_value: true, important: true, name: show_style_buttons, type: boolean}
- {default_value: true, important: true, name: show_copy_button, type: boolean}
- {default_value: true, important: true, name: show_align_buttons, type: boolean}
