components: []
container:
  properties:
    html: |-
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <!-- Responsive for mobile devices -->
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Audio Management Interface</title>

          <!-- Add RecordRTC for iOS compatibility -->
          <script src="https://www.webrtc-experiment.com/RecordRTC.js"></script>

          <!-- Add NoSleep.js for fallback wake lock on older browsers -->
          <script src="https://cdnjs.cloudflare.com/ajax/libs/nosleep/0.12.0/NoSleep.min.js"></script>

          <style>
            /* =====================================================
            Basic styles
            ===================================================== */
            * {
            box-sizing: border-box;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            }
            body {
            background-color: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            }
            .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            /* =====================================================
            Fixed section (tabs + actions)
            ===================================================== */
            .fixed-section {
            background: white;
            z-index: 10;
            }
            .nav-tabs {
            display: flex;
            width: 100%;
            border-bottom: 1px solid #ddd;
            }
            .nav-tab {
            flex: 1;
            padding: 8px 16px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            background: #f8f8f8;
            font-size: 14px;
            position: relative;
            margin-right: -1px;
            text-align: center;
            }
            .nav-tab.active {
            background: #e5e5e5;
            border-top: 1px solid #999;
            border-left: 1px solid #999;
            border-right: 1px solid #999;
            border-bottom: 1px solid #e5e5e5;
            margin-bottom: -1px;
            }
            .actions-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 15px 20px;
            }
            .time {
            color: #666;
            font-size: 14px;
            }
            /* =====================================================
            Scrollable content
            ===================================================== */
            .scrollable-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 80px;
            -webkit-overflow-scrolling: touch;
            }

            /* =====================================================
            AUDIO section (playback + recording)
            ===================================================== */
            .audio-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            position: relative;
            }
            #audioBar {
            width: 100%;
            height: 50px;
            background-color: #f8f8f8;
            border-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            position: relative;
            }
            /* PC Controls */
            #audioPlaybackControl {
            width: 30px;
            height: 30px;
            background-color: #4CAF50;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
            }
            #audioProgress {
            flex-grow: 1;
            height: 10px;
            background-color: #ddd;
            border-radius: 5px;
            overflow: hidden;
            cursor: pointer;
            margin-right: 10px;
            touch-action: none;
            }
            #audioProgressBar {
            width: 0;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.1s linear;
            }
            #audioDuration {
            font-size: 14px;
            }
            #clearRecordingButton {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            margin-left: 10px;
            }
            #clearRecordingButton:hover {
            color: #000;
            }
            #retryProcessBtn {
            position: absolute;
            top: -40px;
            right: 10px;
            padding: 8px 12px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: none;
            }
            .recording-controls {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 20px auto;
            }
            #circularProgress {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 0 auto;
            border-radius: 50%;
            overflow: hidden;
            }
            #progressRing {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(#ddd 0deg, #ddd 0deg);
            }
            #centerHole {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 184px;
            height: 184px;
            background-color: #fff;
            border-radius: 50%;
            z-index: 1;
            }
            .control-button-group {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 30px;
            z-index: 2;
            }
            .control-button {
            width: 45px;
            height: 45px;
            border: 1px solid #666;
            border-radius: 2px;
            cursor: pointer;
            background-color: white;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s ease;
            padding: 0;
            }
            .control-button svg {
            pointer-events: none;
            }
            .control-button:hover {
            background-color: #f5f5f5;
            border-color: #333;
            color: #333;
            }

            /* =====================================================
            Upload Voice Memo Section for all devices
            ===================================================== */
            .upload-section {
            margin: 20px auto;
            max-width: 400px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            }

            .upload-container {
            width: 100%;
            border: 2px dashed #aaa;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            background-color: #f8f8f8;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 15px;
            }

            .upload-container:hover {
            border-color: #4CAF50;
            background-color: #f0f9f0;
            }

            .upload-container.dragover {
            border-color: #4CAF50;
            background-color: #e7f6e7;
            transform: scale(1.02);
            }

            .upload-icon {
            font-size: 40px;
            color: #666;
            margin-bottom: 10px;
            }

            .upload-text {
            color: #333;
            font-size: 16px;
            margin-bottom: 5px;
            }

            .upload-description {
            color: #666;
            font-size: 14px;
            margin-bottom: 15px;
            }

            .upload-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
            min-height: 44px; /* iOS minimum touch target size */
            }

            .upload-button:hover {
            background-color: #45a049;
            }

            .upload-button:active {
            transform: scale(0.98);
            opacity: 0.9;
            }

            #audioFileInput {
            display: none;
            }

            .file-info {
            display: none;
            margin-top: 15px;
            padding: 10px;
            background-color: #e8f5e9;
            border-radius: 5px;
            width: 100%;
            font-size: 14px;
            }

            .file-name {
            font-weight: bold;
            word-break: break-all;
            }

            .file-size {
            color: #666;
            }

            .file-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            }

            .file-button {
            padding: 5px 10px;
            border-radius: 3px;
            border: none;
            font-size: 14px;
            cursor: pointer;
            min-height: 36px;
            }

            .process-file-button {
            background-color: #4CAF50;
            color: white;
            }

            .remove-file-button {
            background-color: #f44336;
            color: white;
            }

            .format-warning {
            display: none;
            margin-top: 10px;
            padding: 8px;
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
            font-size: 13px;
            color: #6d4c41;
            }

            /* iOS-specific guidance */
            .ios-instructions {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #007aff;
            border-radius: 4px;
            font-size: 14px;
            display: none; /* Hidden by default, shown by JS for iOS */
            }

            .ios-instructions h4 {
            color: #007aff;
            margin-top: 0;
            margin-bottom: 10px;
            }

            .ios-instructions ol {
            padding-left: 20px;
            }

            .ios-instructions li {
            margin-bottom: 8px;
            }

            /* Toggle between upload and recording */
            .mode-toggle {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            }

            .toggle-button {
            padding: 8px 16px;
            margin: 0 5px;
            background-color: #f1f1f1;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            }

            .toggle-button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
            }

            @keyframes recordingFlash {
            0% { background: conic-gradient(#ffe5e5 0deg, #ffe5e5 360deg); }
            50% { background: conic-gradient(#ffffff 0deg, #ffffff 360deg); }
            100% { background: conic-gradient(#ffe5e5 0deg, #ffe5e5 360deg); }
            }
            .recording-flash {
            animation: recordingFlash 1.5s infinite;
            }
            /* Mobile audio display (only on mobile) */
            #mobileAudioDisplay {
            display: none;
            width: 100%;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            }

            /* =====================================================
            Settings Section
            ===================================================== */
            .parameters-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            }
            .parameter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            }
            .parameter-row label {
            font-weight: bold;
            margin-right: 10px;
            }
            .template-select-container .select-button {
            min-width: 200px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            }
            .dropdown {
            min-width: 200px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            }
            .arrow { margin-left: 10px; color: #666; }
            .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: none;
            z-index: 1000;
            }
            .dropdown-menu.active { display: block; }
            .dropdown-menu div {
            padding: 8px;
            cursor: pointer;
            }
            .dropdown-menu div:hover { background: #f5f5f5; }
            /* =====================================================
            Editor Section
            ===================================================== */
            .editor-section {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            }
            #toolbar {
            padding: 10px;
            background: #f8f8f8;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            }
            .toolbar-button {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            }
            .toolbar-button:hover { background: #f5f5f5; }

            /* Single highlight for the "Start TB Rec" button while recording: */
            .tb-recording-flash {
            background-color: #ffebe6 !important;
            border-color: #ff6347 !important;
            color: #ff6347 !important;
            }

            /* Highlight for "Validate" button while AI processes snippet: */
            .tb-processing-flash {
            background-color: #e6ffe6 !important;
            border-color: #4CAF50 !important;
            color: #4CAF50 !important;
            }

            .toolbar-button.recording {
            background-color: #ffebe6;
            border-color: #ff6347;
            color: #ff6347;
            }
            .toolbar-button.validate {
            background-color: #e6ffe6;
            border-color: #4CAF50;
            color: #4CAF50;
            }
            #editor {
            min-height: 300px;
            padding: 20px;
            border: 1px solid #ddd;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.5;
            }
            .scrollable-content::-webkit-scrollbar { width: 8px; }
            .scrollable-content::-webkit-scrollbar-track { background: #f1f1f1; }
            .scrollable-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
            }
            .scrollable-content::-webkit-scrollbar-thumb:hover { background: #555; }

            /* =====================================================
            Bottom buttons
            ===================================================== */
            .bottom-buttons {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            max-width: 100%;
            background: white;
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            border-top: 1px solid #ddd;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            z-index: 10;
            }
            .bottom-button {
            padding: 10px 30px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            }
            .bottom-button:hover {
            background: #f5f5f5;
            border-color: #999;
            }

            /* =====================================================
            Patient selection modal (for saving)
            ===================================================== */
            .patient-select-container {
            position: relative;
            width: 300px;
            font-family: system-ui, -apple-system, sans-serif;
            }
            .select-button#patientSelectBtn { display: none; }
            .modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            }
            .modal-content {
            position: relative;
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }
            .modal-header { margin-bottom: 20px; }
            .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 15px 0;
            }
            .search-container { position: relative; margin-bottom: 20px; }
            .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            color: #666;
            }
            #patientSearchHolder {
            /* Container rebuilt dynamically */
            }
            .search-input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
            }
            .search-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
            }
            .new-patient-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            border-radius: 6px;
            color: #16a34a;
            cursor: pointer;
            font-size: 14px;
            text-align: left;
            }
            .new-patient-btn:hover { background-color: #f0fdf4; }
            .divider {
            height: 1px;
            background-color: #ddd;
            margin: 15px 0;
            }
            .patients-list { max-height: 200px; overflow-y: auto; }
            .patient-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            border-radius: 6px;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            }
            .patient-item:hover { background-color: #f3f4f6; }
            .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            color: #666;
            }

            /* =====================================================
            Template selection modal
            ===================================================== */
            .template-select-container .modal {
            z-index: 1100;
            }
            #templateModal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            }
            #templateModal .modal-content {
            margin: 15% auto;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            }
            #templateModal .modal-header { margin-bottom: 20px; }
            #templateModal .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 15px 0;
            }
            #templateModal .search-container { position: relative; margin-bottom: 20px; }
            #templateModal .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            color: #666;
            }
            #templateModal .search-input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
            }
            #templateModal .templates-list { max-height: 300px; overflow-y: auto; }
            #templateModal .template-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            border-radius: 6px;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            }
            #templateModal .template-item:hover { background: #f3f4f6; }
            #templateModal .star-icon {
            font-size: 16px;
            line-height: 1;
            }
            #templateModal .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            color: #666;
            }

            /* =====================================================
            Banners (temporary messages)
            ===================================================== */
            #bannerContainer {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            }
            /* Flashing banner to indicate ongoing toolbar recording.
            We'll toggle .flash-state every second for a "blink" effect. */
            .banner-flash {
            background-color: #f44336;
            margin-bottom: 10px;
            padding: 10px 20px;
            border-radius: 4px;
            color: #fff;
            opacity: 0.9;
            font-size: 14px;
            min-width: 200px;
            text-align: center;
            transition: background-color 0.3s ease;
            }
            .banner-flash.flash-state {
            background-color: #ff7961;
            }

            .banner {
            margin-bottom: 10px;
            padding: 10px 20px;
            border-radius: 4px;
            color: #fff;
            opacity: 0.9;
            font-size: 14px;
            min-width: 200px;
            text-align: center;
            }
            .banner-success {
            background-color: #4caf50;
            }
            .banner-error {
            background-color: #f44336;
            }

            /* =====================================================
            Responsive design (mobile)
            ===================================================== */
            @media (max-width: 800px) {
            .container {
            height: 100vh;
            }
            .bottom-buttons {
            width: 100%;
            left: 0;
            transform: none;
            }
            .nav-tab {
            font-size: 12px;
            padding: 6px 8px;
            }
            .actions-row {
            padding: 10px 15px;
            }
            #audioBar {
            height: auto;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            }
            #audioPlaybackControl,
            #audioProgress,
            #audioDuration,
            #clearRecordingButton {
            display: none;
            }
            #mobileAudioDisplay {
            display: block;
            }
            .recording-controls {
            width: 180px;
            height: 180px;
            }
            #circularProgress {
            width: 180px;
            height: 180px;
            }
            #centerHole {
            top: 7px;
            left: 7px;
            width: 166px;
            height: 166px;
            }

            /* Enhanced Upload mode on mobile */
            .upload-section {
            margin-top: 10px;
            }
            .mode-toggle {
            margin-bottom: 10px;
            padding-bottom: 10px;
            }
            .toggle-button {
            font-size: 13px;
            padding: 6px 12px;
            }

            /* iOS-specific adjustments */
            @supports (-webkit-touch-callout: none) {
            /* Make buttons larger for better touch targets on iOS */
            .upload-button, .file-button, .toggle-button {
            padding: 12px 20px;
            min-height: 44px; /* iOS minimum recommended touch target size */
            font-size: 16px; /* Prevent zoom on focus in iOS */
            }
            }
            }
          </style>
        </head>
        <body>
          <div class="container">
            <!-- Fixed section: Tabs + Actions -->
            <div class="fixed-section">
              <div class="nav-tabs">
                <button class="nav-tab active" data-click="production" id="nav_production">Production</button>
                <button class="nav-tab" data-click="templates" id="nav_templates">Templates/AI</button>
                <button class="nav-tab" data-click="archives" id="nav_archives">Archives</button>
                <button class="nav-tab" data-click="settings" id="nav_settings">Settings</button>
              </div>
              <div class="actions-row">
                <div class="time">11:44</div>
              </div>
            </div>

            <!-- Scrollable content -->
            <div class="scrollable-content">
              <!-- Audio Section (Playback + Recording) -->
              <div class="audio-section">
                <div id="audioBar">
                  <button id="audioPlaybackControl">▶</button>
                  <div id="audioProgress">
                    <div id="audioProgressBar"></div>
                  </div>
                  <span id="audioDuration">0:00 / 0:00</span>
                  <button id="clearRecordingButton" title="Reset recording">🗑</button>
                  <button id="retryProcessBtn">Reprocess my audio with AI</button>
                  <div id="mobileAudioDisplay"></div>
                </div>

                <!-- Mode toggle -->
                <div class="mode-toggle">
                  <button id="recordButton" class="toggle-button active">Record</button>
                  <button id="uploadButton" class="toggle-button">Upload a voice memo</button>
                </div>

                <!-- Recording Mode -->
                <div class="recording-controls" id="recordingMode">
                  <div id="circularProgress">
                    <div id="progressRing"></div>
                    <div id="centerHole"></div>
                    <div class="control-button-group">
                      <button id="playButton" class="control-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                          <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                          <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                        </svg>
                      </button>
                      <button id="stopButton" class="control-button">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                          <path d="M4 12l5 5L20 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                      </button>
                    </div>
                  </div>
                </div>

                <!-- Upload Mode - Optimized for iOS -->
                <div class="upload-section" id="uploadMode" style="display: none;">
                  <div class="upload-container" id="dropZone">
                    <div class="upload-icon">📋</div>
                    <div class="upload-text" id="upload_text_drop">Drop your voice memo here</div>
                    <div class="upload-description" id="upload_description_select">or click to select a file</div>
                    <!-- File input with accept extended to include iOS formats -->
                    <input type="file" id="audioFileInput" accept="audio/*,.m4a,.caf">
                    <label for="audioFileInput" class="upload-button" id="upload_button_select">Select file</label>
                  </div>

                  <!-- Instructions for iOS (displayed only on iOS) -->
                  <div class="ios-instructions">
                    <h4>For iPhone users:</h4>
                    <p>To use your voice memos:</p>
                    <ol>
                      <li>Open the <strong>Files</strong> app on your iPhone</li>
                      <li>Locate the voice memo (it may be in <strong>On My iPhone > Voice Memos</strong>)</li>
                      <li>Tap and hold on the file to see options</li>
                      <li>Choose <strong>"Share"</strong></li>
                      <li>Select <strong>"Save to Files"</strong></li>
                      <li>Save it to an accessible location like <strong>iCloud Drive</strong></li>
                      <li>Return to this page and use the <strong>"Select file"</strong> button</li>
                    </ol>
                  </div>

                  <div class="file-info" id="fileInfo">
                    <div class="file-name" id="fileName">memo.m4a</div>
                    <div class="file-size" id="fileSize">2.4 MB</div>
                    <div class="file-actions">
                      <button class="file-button process-file-button" id="processFileButton">Process file</button>
                      <button class="file-button remove-file-button" id="removeFileButton">Remove</button>
                    </div>
                  </div>

                  <div class="format-warning" id="formatWarning">
                    This file format might not be compatible with iOS Voice Memos.
                    Recommended formats are: .m4a, .mp3, .aac
                  </div>
                </div>

                <audio id="audioPlayback" style="display: none;"></audio>
              </div>

              <!-- Settings Section -->
              <div class="parameters-section">
                <div class="parameter-row">
                  <label id="label_template">Template</label>
                  <div class="template-select-container">
                    <button class="select-button" id="templateSelectBtn">
                      <span id="select_template_placeholder">Select a template</span>
                      <span>▼</span>
                    </button>
                  </div>
                </div>
                <div class="parameter-row">
                  <label id="label_language">Language</label>
                  <div class="dropdown" id="langueDropdown">
                    <span>🇬🇧</span>
                    <span class="arrow">▼</span>
                    <div class="dropdown-menu">
                      <div data-value="🇫🇷">🇫🇷</div>
                      <div data-value="🇬🇧">🇬🇧</div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Editor Section -->
              <div class="editor-section">
                <div id="toolbar">
                  <button class="toolbar-button" id="boldBtn"><b>B</b></button>
                  <button class="toolbar-button" id="italicBtn"><i>I</i></button>
                  <button class="toolbar-button" id="underlineBtn"><u>U</u></button>
                  <button class="toolbar-button" id="leftAlignBtn">Left</button>
                  <button class="toolbar-button" id="centerAlignBtn">Center</button>
                  <button class="toolbar-button" id="rightAlignBtn">Right</button>
                  <button class="toolbar-button" id="insertImageBtn" id="toolbar_image">Image</button>

                  <!-- SINGLE Start TB Rec button with mic icon only -->
                  <button class="toolbar-button recording" id="startToolbarRecBtn" title="Toolbar recording">🎤</button>

                  <!-- Validate button also finalizes any toolbar snippet if recording -->
                  <button class="toolbar-button validate" id="validateBtn" title="Validate and send">✓</button>

                  <span style="margin-left:auto;"></span>
                  <button class="toolbar-button" id="copyBtn" id="toolbar_copy">Copy</button>
                </div>
                <div id="editor" contenteditable="true"></div>
              </div>

              <!-- HIDDEN ANCHOR so we can call anvil.call() on a real child element -->
              <div id="toolbarRecorderAnchor" style="display:none;"></div>
            </div>

            <!-- Bottom buttons -->
            <div class="bottom-buttons">
              <button class="bottom-button" data-click="statut" id="button_status">Status</button>
              <button class="bottom-button" data-click="enregistrer" id="button_archive">Archive</button>
              <button class="bottom-button" data-click="partager" id="button_share">Share</button>
            </div>
          </div>

          <!-- Patient selection modal -->
          <div class="patient-select-container">
            <button class="select-button" id="patientSelectBtn" style="display:none;">
              <span>Select a patient</span>
              <span>▼</span>
            </button>
            <div class="modal" id="patientModal">
              <div class="modal-content">
                <button class="close-button" id="closePatientModalBtn">✕</button>
                <div class="modal-header">
                  <h3 class="modal-title" id="select_patient_title">Select a patient</h3>
                  <div class="search-container">
                    <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="11" cy="11" r="8"></circle>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <div id="patientSearchHolder">
                      <input type="text" class="search-input" placeholder="Search for a patient..." id="searchInput">
                    </div>
                  </div>
                </div>
                <button class="new-patient-btn" id="newPatientBtn">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <line x1="19" y1="8" x2="19" y2="14"></line>
                    <line x1="16" y1="11" x2="22" y2="11"></line>
                  </svg>
                  New patient
                </button>
                <div class="divider"></div>
                <div class="patients-list" id="patientsList">
                  <!-- Patient list inserted dynamically -->
                </div>
              </div>
            </div>
          </div>

          <!-- Template selection modal -->
          <div class="template-select-container">
            <div class="modal" id="templateModal">
              <div class="modal-content">
                <button class="close-button" id="closeTemplateModalBtn">✕</button>
                <div class="modal-header">
                  <h3 class="modal-title" id="select_template_title">Select a template</h3>
                  <div class="search-container">
                    <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="11" cy="11" r="8"></circle>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <input type="text" class="search-input" placeholder="Search for a template..." id="templateSearchInput">
                  </div>
                </div>
                <div class="templates-list" id="templatesList">
                  <!-- Template list inserted dynamically -->
                </div>
              </div>
            </div>
          </div>

          <!-- Banners for temporary messages -->
          <div id="bannerContainer"></div>

          <!-- External libraries for PDF -->
          <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
          <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

          <!-- Main script (JS) -->
          <script>
            // Define functions that Python might call directly OUTSIDE the initialization guard
            // These must be directly on window to ensure they can be called from Python

            // Function to get the selected value from a dropdown (used by Python backend)
            window.getDropdownSelectedValue = function(dropdownId) {
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) return "";

            // Special handling for template selection dropdown - return clean name without stars
            if (dropdownId === "templateSelectBtn" && dropdown.dataset.templateName) {
            return dropdown.dataset.templateName;
            }

            // Default behavior for other dropdowns like language
            const spanElem = dropdown.querySelector("span:first-child");
            if (!spanElem) return "";

            return spanElem.textContent.trim();
            };

            // Get editor content (used by Python backend)
            window.getEditorContent = function() {
            const editor = document.getElementById('editor');
            return editor ? editor.innerHTML : "";
            };

            // Set editor content (used by Python backend)
            window.setEditorContent = function(value) {
            const editor = document.getElementById('editor');
            if (editor) editor.innerHTML = value;
            };

            // Function to display banners (used by Python backend)
            window.displayBanner = function(message, type) {
            const bannerContainer = document.getElementById('bannerContainer');
            if (!bannerContainer) return;

            const banner = document.createElement('div');
            banner.className = 'banner ' + (type === 'success' ? 'banner-success' : 'banner-error');
            banner.textContent = message;
            bannerContainer.appendChild(banner);

            setTimeout(() => {
            banner.style.opacity = '0';
            setTimeout(() => {
            if (banner.parentNode) {
            banner.parentNode.removeChild(banner);
            }
            }, 300);
            }, 3000);
            };

            // Critical function that gets called by Python immediately
            window.rebuildPatientSearchInput = function() {
            console.log("[DEBUG JS] rebuildPatientSearchInput called");
            var searchHolder = document.getElementById("patientSearchHolder");
            if (searchHolder) {
            var newInput = document.createElement("input");
            newInput.type = "text";
            newInput.className = "search-input";
            newInput.id = "searchInput";
            newInput.placeholder = "Search for a patient...";

            newInput.addEventListener('input', function() {
            // Use a safe way to call searchPatientsInModal
            if (window.searchPatientsInModal) {
            window.searchPatientsInModal(this.value);
            } else {
            console.error("[DEBUG JS] searchPatientsInModal not available yet");
            // Try calling it directly without window
            try {
            searchPatientsInModal(this.value);
            } catch (e) {
            console.error("[DEBUG JS] Direct call also failed:", e);
            }
            }
            });

            searchHolder.innerHTML = "";
            searchHolder.appendChild(newInput);
            } else {
            console.error("[DEBUG JS] Could not find patientSearchHolder element");
            }
            };

            // Populate the template modal with templates data (used by Python backend)
            window.populateTemplateModal = function(templates) {
            templates = templates.filter(t => t.priority === 1 || t.priority === 2);
            templates.sort((a, b) => {
            if (a.priority === 2 && b.priority !== 2) return -1;
            if (b.priority === 2 && a.priority !== 2) return 1;
            return 0;
            });
            window.templatesData = templates;

            let defaultTemplate = templates.find(t => t.priority === 2);
            if (!defaultTemplate) { defaultTemplate = templates[0]; }

            if (defaultTemplate) {
            let starColor = defaultTemplate.priority === 2 ? "green" : "yellow";
            const templateButton = document.getElementById('templateSelectBtn');
            if (templateButton) {
            // Store the original template name as a data attribute
            templateButton.dataset.templateName = defaultTemplate.template_name;

            // Display the template name with star for visual indication
            const displaySpan = templateButton.querySelector('span:first-child');
            if (displaySpan) {
            displaySpan.innerHTML =
            defaultTemplate.template_name + ' <span class="star-icon" style="color:' + starColor + '">★</span>';
            }
            }

            // Always clear the editor first
            window.setEditorContent('');

            // Then set content if applicable for this template
            if (defaultTemplate.display_template === true && defaultTemplate.text_to_display) {
            console.log("[DEBUG] Default template has display_template=true, updating editor content");
            window.setEditorContent(defaultTemplate.text_to_display);
            }

            // Store the selected template
            window.selectedTemplate = defaultTemplate;
            }

            // Use safe way to call renderTemplates
            if (window.renderTemplates) {
            window.renderTemplates(templates);
            } else {
            console.error("[DEBUG JS] renderTemplates not available yet when populateTemplateModal was called");
            }
            };

            // --------------------------------------------------------------------------------------------
            // GOLDEN RULE 1: Define Global Variables and Helper Functions Only Once
            // --------------------------------------------------------------------------------------------
            if (!window.__my_audio_manager_globals) {
            window.__my_audio_manager_globals = true;

            window.setElementText = function(elementId, newText) {
            const element = document.getElementById(elementId);
            if (element) {
            element.textContent = newText;
            }
            };

            window.setPlaceholderById = function(elementId, newText) {
            const element = document.getElementById(elementId);
            if (element) {
            element.placeholder = newText;
            }
            };

            // Global state for audio recording
            window.recordingState = {
            mediaRecorder: null,
            recordedChunks: [],
            audioBlob: null,
            stream: null,
            isRecording: false,
            isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
            recordRTC: null,
            uploadedFile: null,
            processingInProgress: false,
            wakeLock: null,
            noSleep: null
            };

            window.wakeLockController = {
            wakeLock: null,
            noSleep: null,

            init: function() {
            if (!this.noSleep) {
            this.noSleep = new NoSleep();
            }
            },

            requestWakeLock: function() {
            this.init();
            // Try Screen Wake Lock API first
            if ('wakeLock' in navigator) {
            navigator.wakeLock.request('screen')
            .then((lock) => {
            console.log('[DEBUG] Wake Lock activated with Screen Wake Lock API');
            this.wakeLock = lock;
            this.wakeLock.addEventListener('release', () => {
            console.log('[DEBUG] Wake Lock was released by the system');
            });
            })
            .catch((err) => {
            console.log('[DEBUG] Failed to activate Screen Wake Lock API, falling back to NoSleep.js:', err);
            this.noSleep.enable();
            });
            } else {
            console.log('[DEBUG] Screen Wake Lock API not supported, using NoSleep.js');
            this.noSleep.enable();
            }
            },

            releaseWakeLock: function() {
            if (this.wakeLock) {
            this.wakeLock.release()
            .then(() => {
            this.wakeLock = null;
            console.log('[DEBUG] Wake Lock released');
            })
            .catch(err => {
            console.log('[DEBUG] Error releasing wake lock:', err);
            });
            }
            if (this.noSleep) {
            this.noSleep.disable();
            }
            }
            };

            // Separate state for toolbar recording
            window.toolbarRecorder = {
            stream: null,
            mediaRecorder: null,
            isRecording: false,
            recordedChunks: [],
            bannerFlashInterval: null
            };

            // Make renderTemplates available on the window object
            window.renderTemplates = function(templatesToRender) {
            const templatesList = document.getElementById('templatesList');
            if (!templatesList) return;

            templatesList.innerHTML = '';

            if (!templatesToRender || templatesToRender.length === 0) {
            templatesList.innerHTML = '<div class="template-item">No templates found</div>';
            return;
            }

            templatesToRender.forEach(template => {
            let starColor = "gray";
            if (template.priority === 2) {
            starColor = "green";
            } else if (template.priority === 1) {
            starColor = "yellow";
            }

            const button = document.createElement('button');
            button.className = 'template-item';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = template.template_name;
            button.appendChild(nameSpan);

            const starSpan = document.createElement('span');
            starSpan.className = 'star-icon';
            starSpan.style.color = starColor;
            starSpan.textContent = '★';
            button.appendChild(starSpan);

            button.addEventListener('click', function() {
            // Pass the entire template object instead of just id/name/color
            window.selectTemplate(template);
            });

            templatesList.appendChild(button);
            });
            };

            // Make all helper functions that might be called from elsewhere available on the window
            window.openPatientModalForSave = function() {
            var modal = document.getElementById('patientModal');
            if (modal) modal.style.display = 'block';
            window.rebuildPatientSearchInput();
            window.searchPatientsInModal('');
            };

            window.closePatientModal = function() {
            var modal = document.getElementById('patientModal');
            if (modal) modal.style.display = 'none';
            };

            window.searchPatientsInModal = function(searchTerm) {
            var modal = document.getElementById('patientModal');
            anvil.call(modal, 'search_patients_relay', searchTerm)
            .then(function(patients) {
            window.renderPatients(patients);
            })
            .catch(function(error){
            console.error("Error searching for patients:", error);
            window.renderPatients([]);
            });
            };

            window.renderPatients = function(patients) {
            const patientsList = document.getElementById('patientsList');
            if (!patientsList) return;

            patientsList.innerHTML = '';

            patients.forEach(patient => {
            const button = document.createElement('button');
            button.className = 'patient-item';
            button.textContent = patient.name;
            button.addEventListener('click', function() {
            window.selectPatientForSave(patient.unique_id, patient.name);
            });
            patientsList.appendChild(button);
            });
            };

            window.selectPatientForSave = function(id, name) {
            window.selectedPatient = { unique_id: id, name: name };
            window.closePatientModal();
            window.continueSave();
            };

            window.newPatientForSave = function() {
            var modal = document.getElementById('patientModal');
            anvil.call(modal, 'get_new_patient_details')
            .then(function(newDetails){
            if(newDetails) {
            window.selectedPatient = { unique_id: null, name: newDetails.name, details: newDetails };
            window.closePatientModal();
            window.continueSave();
            }
            })
            .catch(function(error){
            console.error("Error getting new patient details:", error);
            });
            };

            window.continueSave = function() {
            var contentJSON = JSON.stringify({ content: window._saveContentData.content });
            var modal = document.getElementById('patientModal');
            anvil.call(modal, 'save_report', contentJSON, window._saveContentData.images, window.selectedPatient)
            .then(function(result){
            if(result) {
            window.displayBanner("Report saved successfully", "success");
            } else {
            alert("Failed to save report");
            }
            })
            .catch(function(error){
            console.error("Error saving report:", error);
            alert("Error: " + error.message);
            });
            };

            // Make available all functions that might be called from elsewhere
            window.openTemplateModal = function() {
            const templateModal = document.getElementById('templateModal');
            if (templateModal) templateModal.style.display = 'block';

            const templateSearchInput = document.getElementById('templateSearchInput');
            if (templateSearchInput) templateSearchInput.value = '';

            window.renderTemplates(window.templatesData || []);
            };

            window.closeTemplateModal = function() {
            const templateModal = document.getElementById('templateModal');
            if (templateModal) templateModal.style.display = 'none';
            };

            window.selectTemplate = function(template) {
            const id = template.id;
            const name = template.template_name;
            const starColor = template.starColor ||
            (template.priority === 2 ? "green" : template.priority === 1 ? "yellow" : "gray");

            const templateButton = document.getElementById('templateSelectBtn');
            if (templateButton) {
            // Store the clean template name as a data attribute
            templateButton.dataset.templateName = name;

            // Display with star for visual indication
            const displaySpan = templateButton.querySelector('span:first-child');
            if (displaySpan) {
            displaySpan.innerHTML =
            name + ' <span class="star-icon" style="color:' + starColor + '">★</span>';
            }
            }

            // First, always clear the editor to ensure a clean state
            // This ensures we don't keep old content when switching templates
            window.setEditorContent('');

            // Then, only set new content if this template should display its content
            if (template.display_template === true && template.text_to_display) {
            console.log("[DEBUG] Template has display_template=true, updating editor content");
            window.setEditorContent(template.text_to_display);
            }

            // Update the stored selected template
            window.selectedTemplate = template;

            window.closeTemplateModal();
            };

            window.searchTemplatesInModal = function(searchTerm) {
            var modal = document.getElementById('templateModal');
            anvil.call(modal, 'search_template_relay', searchTerm)
            .then(function(templates) {
            window.renderTemplates(templates);
            })
            .catch(function(error){
            console.error("Error searching templates:", error);
            window.renderTemplates([]);
            });
            };

            // Set up iOS recorder with enhanced configuration
            window.initializeIOSRecording = function(state, event) {
            state.recordRTC = new RecordRTC(state.stream, {
            disableLogs: false,
            type: 'audio',
            mimeType: 'audio/wav',
            recorderType: RecordRTC.StereoAudioRecorder,
            bufferSize: 16384,
            sampleRate: 44100,
            numberOfAudioChannels: 1,
            timeSlice: 10000,
            checkForInactiveTracks: true,
            desiredSampRate: 44100
            });

            state.recordRTC.startRecording();
            state.isRecording = true;

            // Update UI
            const playButton = document.getElementById("playButton");
            if (playButton) {
            playButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
            <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
            <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
            `;
            }

            // Notify backend
            anvil.call(event.target, "start_recording");
            window.startRecordingFlash();
            };

            // Helper functions for audio playback
            window.updateAudioProgress = function() {
            const audioPlayback = document.getElementById("audioPlayback");
            const audioProgressBar = document.getElementById("audioProgressBar");
            const audioDuration = document.getElementById("audioDuration");

            if (!audioPlayback || !audioPlayback.duration) return;

            const progress = (audioPlayback.currentTime / audioPlayback.duration) * 100;
            if (audioProgressBar) {
            audioProgressBar.style.width = `${progress}%`;
            }

            if (audioDuration) {
            audioDuration.textContent = `${window.formatTime(audioPlayback.currentTime)} / ${window.formatTime(audioPlayback.duration)}`;
            }
            };

            window.updateAudioDuration = function() {
            const audioPlayback = document.getElementById("audioPlayback");
            const audioDuration = document.getElementById("audioDuration");

            if (!audioPlayback || !audioPlayback.duration) return;

            if (audioDuration) {
            audioDuration.textContent = `0:00 / ${window.formatTime(audioPlayback.duration)}`;
            }
            };

            window.setupIOSSupport = function() {
            console.log("[DEBUG] Setting up iOS-specific enhancements");

            // Show iOS-specific instructions
            const iosInstructions = document.querySelector('.ios-instructions');
            if (iosInstructions) {
            iosInstructions.style.display = 'block';
            }

            // Ensure file input accepts iOS formats
            const audioFileInput = document.getElementById('audioFileInput');
            if (audioFileInput) {
            audioFileInput.setAttribute('accept', 'audio/*,.m4a,.caf,.aac,.mp4');
            }

            // Enhance button sizes for iOS
            const uploadButton = document.querySelector('.upload-button');
            if (uploadButton) {
            uploadButton.style.minHeight = '44px';
            uploadButton.style.fontSize = '16px';
            uploadButton.style.padding = '12px 20px';
            }

            // Add helpful alert for iOS users
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
            // Replace with a new one to clear any existing handlers
            const newDropZone = dropZone.cloneNode(true);
            dropZone.parentNode.replaceChild(newDropZone, dropZone);

            newDropZone.addEventListener('click', function(e) {
            // Don't interfere with clicks on buttons or inputs
            if (e.target.classList.contains('upload-button') || e.target.tagName === 'INPUT') {
            return;
            }

            // Show a helpful tip before opening the file selector
            if (confirm("Tip for iPhone: If you don't see your voice memos, try saving them to the Files app first.\\n\\nOpen file selector?")) {
            const audioFileInput = document.getElementById('audioFileInput');
            if (audioFileInput) audioFileInput.click();
            }
            });
            }
            };

            /* ---------- STOP-BUTTON UX ---------- */
            window.setStopButtonBusy = function (busy) {
            const stopBtn = document.getElementById('stopButton');
            if (!stopBtn) return;

            if (busy) {
            stopBtn.disabled = true;               // block double-taps
            stopBtn.dataset.prevHTML = stopBtn.innerHTML;  // keep the icon
            stopBtn.innerHTML = 'Stopping…';       // quick textual feedback
            } else {
            stopBtn.disabled = false;
            if (stopBtn.dataset.prevHTML) {
            stopBtn.innerHTML = stopBtn.dataset.prevHTML;
            delete stopBtn.dataset.prevHTML;
            }
            }
            };


            // Update time display
            window.updateTime = function() {
            const now = new Date();
            const hrs = now.getHours().toString().padStart(2, '0');
            const mins = now.getMinutes().toString().padStart(2, '0');
            const timeElement = document.querySelector('.time');
            if (timeElement) {
            timeElement.textContent = `${hrs}:${mins}`;
            }
            };

            // Globally exposed methods
            window.blobToBase64 = function(blob) {
            return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
            const resultStr = reader.result;
            const base64 = resultStr.split(',')[1];
            resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
            });
            };

            // Update progress ring UI
            window.setRingPercentage = function(percentage) {
            const ringElem = document.getElementById("progressRing");
            if (!ringElem) return;

            const clamped = Math.max(0, Math.min(100, percentage));
            const angle = (clamped / 100) * 360;
            ringElem.style.background = `conic-gradient(#4caf50 ${angle}deg, #ddd ${angle}deg)`;
            };

            // Visual feedback for recording state
            window.startRecordingFlash = function() {
            const ringElem = document.getElementById("progressRing");
            if (ringElem) {
            ringElem.classList.add("recording-flash");
            }
            };

            window.stopRecordingFlash = function() {
            window.setStopButtonBusy(true);
            const ringElem = document.getElementById("progressRing");
            if (ringElem) {
            ringElem.classList.remove("recording-flash");
            }
            };

            // Simulate progress for transcription process
            window.simulateTranscriptionProgress = function() {
            window.transcriptionProgress = {
            currentProgress: 0,
            intervalId: null
            };

            window.setRingPercentage(0);
            window.transcriptionProgress.intervalId = setInterval(() => {
            if (window.transcriptionProgress.currentProgress < 90) {
            window.transcriptionProgress.currentProgress += 1;
            window.setRingPercentage(window.transcriptionProgress.currentProgress);
            } else {
            clearInterval(window.transcriptionProgress.intervalId);
            }
            }, 400);
            };

            window.finishTranscriptionProgress = function() {
            if (window.transcriptionProgress && window.transcriptionProgress.intervalId) {
            clearInterval(window.transcriptionProgress.intervalId);
            }
            window.setRingPercentage(100);
            };

            // Mobile audio display update
            window.updateMobileAudioDisplay = function() {
            var display = document.getElementById("mobileAudioDisplay");
            if (!display) return;

            if (window.recordingState.audioBlob) {
            display.innerHTML = "Audio 🎵 <button id='mobileClearButton' onclick='clearRecording(event)'>🗑</button>";

            // Add event listener to the newly created button
            const mobileClearButton = document.getElementById("mobileClearButton");
            if (mobileClearButton) {
            mobileClearButton.addEventListener("click", function(e) {
            e.preventDefault();
            e.stopPropagation();
            window.clearRecording(e);
            });
            }
            } else {
            display.innerHTML = "";
            }
            };

            // Recording functions
            window.startRecording = async function(event) {
            const state = window.recordingState;

            // Prevent multiple recording sessions
            if (state.isRecording) {
            console.log('[DEBUG] Recording already in progress');
            return;
            }

            // Request wake lock to keep screen on
            window.wakeLockController.requestWakeLock();

            try {
            // Request microphone access
            state.stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            if (state.isIOS) {
            // iOS-specific implementation with RecordRTC
            console.log('[DEBUG] Starting iOS recording with RecordRTC');

            if (typeof RecordRTC === 'undefined') {
            // Load RecordRTC if not already loaded
            const script = document.createElement('script');
            script.src = 'https://www.webrtc-experiment.com/RecordRTC.js';
            script.onload = function() {
            window.initializeIOSRecording(state, event);
            };
            document.head.appendChild(script);
            } else {
            window.initializeIOSRecording(state, event);
            }
            } else {
            // Standard WebRTC implementation
            console.log('[DEBUG] Starting standard recording with MediaRecorder');

            state.mediaRecorder = new MediaRecorder(state.stream);
            state.recordedChunks = [];

            state.mediaRecorder.ondataavailable = e => {
            if (e.data.size > 0) {
            state.recordedChunks.push(e.data);
            }
            };

            state.mediaRecorder.start();
            state.isRecording = true;

            // Update UI
            const playButton = document.getElementById("playButton");
            if (playButton) {
            playButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
            <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
            <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
            `;
            }

            // Notify backend
            anvil.call(event.target, "start_recording");
            window.startRecordingFlash();
            }
            } catch (err) {
            console.error('[DEBUG] Error accessing microphone:', err);
            alert("Unable to access microphone. Please check permissions.");

            // Release wake lock if we couldn't start recording
            window.wakeLockController.releaseWakeLock();
            }
            };

            // Pause recording
            window.pauseRecording = function(event) {
            const state = window.recordingState;

            if (!state.isRecording) {
            console.log('[DEBUG] No recording to pause');
            return;
            }

            if (state.isIOS) {
            if (state.recordRTC) {
            console.log('[DEBUG] Pausing iOS recording');
            state.recordRTC.pauseRecording();
            state.isRecording = false;

            // Update UI
            const playButton = document.getElementById("playButton");
            if (playButton) {
            playButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
            <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
            <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
          </svg>
            `;
            }

            // Notify backend
            anvil.call(event.target, "pause_recording");
            }
            } else {
            if (state.mediaRecorder && state.mediaRecorder.state === "recording") {
            console.log('[DEBUG] Pausing standard recording');
            state.mediaRecorder.pause();
            state.isRecording = false;

            // Update UI
            const playButton = document.getElementById("playButton");
            if (playButton) {
            playButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
            <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
            <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
          </svg>
            `;
            }

            // Notify backend
            anvil.call(event.target, "pause_recording");
            }
            }
            };

            // Resume recording
            window.resumeRecording = function(event) {
            const state = window.recordingState;

            if (state.isRecording) {
            console.log('[DEBUG] Recording already active');
        return;
                    }

                    if (state.isIOS) {
                    if (state.recordRTC) {
                    console.log('[DEBUG] Resuming iOS recording');
                    state.recordRTC.resumeRecording();
                    state.isRecording = true;

                    // Update UI
                    const playButton = document.getElementById("playButton");
                    if (playButton) {
                    playButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                    <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
                    <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  </svg>
                    `;
                    }

                    // Notify backend
                    anvil.call(event.target, "start_recording");
                    }
                    } else {
                    if (state.mediaRecorder && state.mediaRecorder.state === "paused") {
                    console.log('[DEBUG] Resuming standard recording');
                    state.mediaRecorder.resume();
                    state.isRecording = true;

                    // Update UI
                    const playButton = document.getElementById("playButton");
                    if (playButton) {
                    playButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                    <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
                    <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  </svg>
                    `;
                    }

                    // Notify backend
                    anvil.call(event.target, "start_recording");
                    }
                    }
                    };

                    // Stop and process recording
                    window.stopRecording = function(event) {
                    const state = window.recordingState;

                    if (state.processingInProgress) {
                    console.log('[DEBUG] Processing already in progress, cannot stop');
                    return;
                    }

                    state.processingInProgress = true;

                    if (state.isIOS) {
                    if (state.recordRTC) {
                    console.log('[DEBUG] Stopping iOS recording');

                    state.recordRTC.stopRecording(function() {
                    const blob = state.recordRTC.getBlob();
                    state.audioBlob = blob;
                    window.lastAudioBlob = blob;

                    // Set up audio playback
                    const audioPlayback = document.getElementById("audioPlayback");
                    if (audioPlayback) {
                    const audioURL = URL.createObjectURL(blob);
                    audioPlayback.src = audioURL;
                    audioPlayback.load();
                    }

                    // Process the recording
                    window.processRecordedAudio(blob, event);

                    // Notify backend
                    anvil.call(event.target, "stop_recording");
                    window.stopRecordingFlash();

                    // Clean up resources
                    state.recordRTC.destroy();
                    if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                    }

                    setTimeout(() => {
                    state.recordRTC = null;
                    state.stream = null;
                    }, 300);
                    });

                    state.isRecording = false;

                    // Update UI
                    const playButton = document.getElementById("playButton");
                    if (playButton) {
                    playButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                    <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                    <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                  </svg>
                    `;
                    }
                    }
                    } else {
                    if (state.mediaRecorder && state.mediaRecorder.state !== "inactive") {
                    console.log('[DEBUG] Stopping standard recording');

                    state.mediaRecorder.onstop = () => {
                    const blob = new Blob(state.recordedChunks, { type: 'audio/webm' });
                    state.audioBlob = blob;
                    window.lastAudioBlob = blob;

                    // Set up audio playback
                    const audioPlayback = document.getElementById("audioPlayback");
                    if (audioPlayback) {
                    const audioURL = URL.createObjectURL(blob);
                    audioPlayback.src = audioURL;
                    audioPlayback.load();
                    }

                    // Process the recording
                    window.processRecordedAudio(blob, event);

                    // Notify backend
                    anvil.call(event.target, "stop_recording");
                    window.stopRecordingFlash();
                    };

                    state.mediaRecorder.stop();
                    state.isRecording = false;

                    // Update UI
                    const playButton = document.getElementById("playButton");
                    if (playButton) {
                    playButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                    <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                    <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                  </svg>
                    `;
                    }
                    }
                    }

                    // Release wake lock after recording
                    window.wakeLockController.releaseWakeLock();
                    };

                    /* ------------------------------------------------------------------
                    Recording upload – “no-chunk” version
                    ------------------------------------------------------------------ */

                    /* Helper: convert a Blob to base-64 (kept for very small files) */
                    window.blobToBase64 = async function (blob) {
                    return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]); // drop data URL header
                    reader.onerror  = reject;
                    reader.readAsDataURL(blob);
                    });
                    };

                    /* --------------------------------------------------------------
                    Main entry: send audio, either as base-64 (< 500 kB) or Media
                    -------------------------------------------------------------- */

                    /* ------------------------------------------------------------------
                    Cut blob into binary chunks
                    ------------------------------------------------------------------ */
                    window.chunkBlob = async function (blob, chunkSize) {
                    const out = [];
                    for (let start = 0; start < blob.size; start += chunkSize) {
                    out.push(blob.slice(start, Math.min(start + chunkSize, blob.size)));
                    }
                    return out;
                    };

                    /* ------------------------------------------------------------------
                    Send recording – <500 kB direct / ≥500 kB chunks base-64
                    ------------------------------------------------------------------ */
                    window.processRecordedAudio = async function (blob, event) {

                    const SMALL_FILE_LIMIT = 500 * 1024;    // 500 kB
                    const CHUNK_SIZE       = 400 * 1024;    // 400 kB (before encoding)

                    try {
                    console.log('[DEBUG] Processing recorded audio');
                    window.simulateTranscriptionProgress();

                    /*// -------- 1.  SMALL files (< 500 kB) keep the old animation -------- */
                    if (blob.size < SMALL_FILE_LIMIT) {
                    const b64 = await window.blobToBase64(blob);
                    return anvil.call(event.target, 'process_recording', b64)
                    .then(handleSuccess)
                    .catch(handleError);
                    }

                    /* -------- 2. Large files: cut + send chunk by chunk -------- */
                    window.setRingPercentage(0);                   // reset once
                    const chunks = await window.chunkBlob(blob, CHUNK_SIZE);
                    console.log(`[DEBUG] Cut into ${chunks.length} chunks`);

                    for (let i = 0; i < chunks.length; i++) {
                    const b64Chunk = await window.blobToBase64(chunks[i]);
                    await anvil.call(event.target, 'receive_audio_chunk', b64Chunk, i, chunks.length);


                    /* progress grows from 0 → 90 % as chunks are sent */
                    const pct = Math.round(((i + 1) / chunks.length) * 90);
                    window.setRingPercentage(pct);
                    }

                    console.log('[DEBUG] All chunks sent – consolidation on Python side');
                    return anvil.call(event.target, 'process_consolidated_audio')
                    .then(handleSuccess)
                    .catch(handleError);

                    } catch (err) {
                    handleError(err);
                    }

                    /* ---------------- helpers ---------------- */
                    function handleSuccess(result) {
                    if (result && typeof result === 'object' && result.error) {
                    alert(result.error);
                    console.warn(result);
                    } else {
                    console.log('[DEBUG] Audio processing complete', result);
                    }
                    window.finishTranscriptionProgress();
                    document.getElementById('retryProcessBtn').style.display = 'block';
                    window.recordingState.processingInProgress = false;
                    window.setStopButtonBusy(false);
                    return result;
                    }

                    function handleError(err) {
                    console.error('[DEBUG] Error processing recording', err);
                    alert('Detailed error: ' + (err?.message || err));
                    window.finishTranscriptionProgress();
                    window.recordingState.processingInProgress = false;
                    }
                    };




                    // Start the separate toolbar recorder
                    window.startToolbarRecording = function(event) {
                    console.log("[DEBUG] Starting separate toolbar recorder...");

                    if (window.toolbarRecorder.isRecording) {
                    alert("A toolbar recording is already in progress.");
                    return;
                    }

                    window.wakeLockController.requestWakeLock();

                    navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                    window.toolbarRecorder.stream = stream;
                    window.toolbarRecorder.mediaRecorder = new MediaRecorder(stream);
                    window.toolbarRecorder.recordedChunks = [];

                    window.toolbarRecorder.mediaRecorder.ondataavailable = evt => {
                    if (evt.data.size > 0) {
                    window.toolbarRecorder.recordedChunks.push(evt.data);
                    }
                    };

                    window.toolbarRecorder.mediaRecorder.start();
                    window.toolbarRecorder.isRecording = true;

                    // Add visual flash to the microphone icon button
                    let startBtn = document.getElementById('startToolbarRecBtn');
                    if (startBtn) {
                    startBtn.classList.add("tb-recording-flash");
                    }

                    // Show the red flashing banner
                    window.startToolbarRecordingBanner();
                    })
                    .catch(err => {
                    console.error("[DEBUG] Error accessing microphone for toolbar:", err);
                    alert("Failed to access microphone (toolbar).");
                    });
                    };

                    // Finalize toolbar recording
                    window.finalizeToolbarRecording = function() {
                    return new Promise((resolve, reject) => {
                    if (!window.toolbarRecorder || !window.toolbarRecorder.isRecording) {
                    // No recording to finalize
                    resolve();
                    return;
                    }

                    console.log("[DEBUG] Stopping toolbar recorder...");

                    // Remove the highlight on the mic icon button
                    let startBtn = document.getElementById('startToolbarRecBtn');
                    if (startBtn) {
                    startBtn.classList.remove("tb-recording-flash");
                    }

                    // Stop the flashing banner
                    window.stopToolbarRecordingBanner();

                    window.toolbarRecorder.mediaRecorder.onstop = function() {
                    console.log("[DEBUG] MediaRecorder (toolbar) stopped. Finalizing blob...");
                    let blob = new Blob(window.toolbarRecorder.recordedChunks, { type: 'audio/webm' });

                    window.processToolbarRecordingBlob(blob)
                    .then(() => {
                    resolve();
                    })
                    .catch(err => {
                    console.error("[DEBUG] Error processing toolbar recording:", err);
                    reject(err);
                    });
                    };

                    window.toolbarRecorder.mediaRecorder.stop();
                    window.toolbarRecorder.isRecording = false;

                    // Clean up resources
                    window.toolbarRecorder.stream.getTracks().forEach(track => track.stop());
                    });
                    };

                    // Process toolbar recording
                    window.processToolbarRecordingBlob = async function(blob) {
                    console.log("[DEBUG] Converting toolbar blob to base64...");

                    try {
                    // Convert to base64
                    let base64Audio = await window.blobToBase64(blob);

                    // Send to Python backend
                    const anchor = document.getElementById("toolbarRecorderAnchor");
                    let resp = await anvil.call(anchor, "process_toolbar_recording", base64Audio);

                    console.log("[DEBUG] Toolbar snippet processed. Response:", resp);
                    return resp;
                    } catch (err) {
                    console.error("[DEBUG] Error converting toolbar blob:", err);
                    alert("Error converting BLOB (toolbar).");
                    throw err;
                    }
                    };

                    // Handle toolbar recording banner
                    window.startToolbarRecordingBanner = function() {
                    const container = document.getElementById('bannerContainer');
                    if (!container) return;

                    // Avoid duplicates
                    let existing = document.getElementById('toolbarRecordingBanner');
                    if (existing) return;

                    let banner = document.createElement('div');
                    banner.id = 'toolbarRecordingBanner';
                    banner.classList.add('banner-flash');
                    banner.textContent = "Recording in progress...";
                    container.appendChild(banner);

                    // Repeatedly toggle .flash-state for the blink effect
                    window.toolbarRecorder.bannerFlashInterval = setInterval(() => {
                    banner.classList.toggle('flash-state');
                    }, 1000);
                    };

                    window.stopToolbarRecordingBanner = function() {
                    let banner = document.getElementById('toolbarRecordingBanner');
                    if (banner && banner.parentNode) {
                    banner.parentNode.removeChild(banner);
                    }

                    if (window.toolbarRecorder && window.toolbarRecorder.bannerFlashInterval) {
                    clearInterval(window.toolbarRecorder.bannerFlashInterval);
                    window.toolbarRecorder.bannerFlashInterval = null;
                    }
                    };

                    // Process uploaded audio file
                    window.processUploadedFile = function(event) {
                    const state = window.recordingState;

                    if (!state.uploadedFile) {
                    alert("Please select an audio file first.");
                    return;
                    }

                    if (state.processingInProgress) {
                    console.log('[DEBUG] Processing already in progress');
                    return;
                    }

                    state.processingInProgress = true;

                    // --- CHANGEMENT 1 : BASCULER LA VUE ET DÉMARRER L'ANIMATION ---\
                    // Cacher la section d'upload et montrer l'anneau de progression. C'est correct.\
                    window.toggleMode('record');
                    window.simulateTranscriptionProgress();
                    // -----------------------------------------------------------\

                    const reader = new FileReader();
                    reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    const blob = new Blob([arrayBuffer], { type: state.uploadedFile.type });

                    window.blobToBase64(blob)
                    .then(base64Audio => {
                    // --- CORRECTION CLÉ : UTILISER UNE ANCRE STABLE ---\
                    // Au lieu de fileInput, nous utilisons un élément qui n'est jamais caché.\
                    const anchor = document.getElementById('toolbarRecorderAnchor');
                    if (!anchor) {
                    console.error("CRITICAL: toolbarRecorderAnchor element not found!");
                    alert("Interface error, please reload.");

                    // Réinitialiser en cas d'erreur critique\
                    window.setRingPercentage(0);
                    window.toggleMode('upload');
                    state.processingInProgress = false;
                    return;
                    }
                    // ----------------------------------------------------\

                    // Appel au serveur (la fonction process_uploaded_audio appelle process_recording)\
                    return anvil.call(anchor, "process_uploaded_audio", base64Audio) // Utilisation de 'anchor' ici\
                    .then(result => {
                    console.log("[DEBUG] Audio file processed. Server response:", result);

                    // --- CHANGEMENT 2 : TERMINER L'ANIMATION EN CAS DE SUCCÈS ---\
                    window.finishTranscriptionProgress();
                    // -----------------------------------------------------------\

                    // Stocker le blob pour une éventuelle relecture ou un nouvel essai\
                    state.audioBlob = blob;
                    window.lastAudioBlob = blob;

                    // Configurer la lecture audio\
                    const audioPlayback = document.getElementById("audioPlayback");
                    if (audioPlayback) {
                    const audioURL = URL.createObjectURL(blob);
                    audioPlayback.src = audioURL;
                    audioPlayback.load();
                    }

                    // Afficher le bouton "Retry"\
                    document.getElementById("retryProcessBtn").style.display = "block";

                    window.updateMobileAudioDisplay();
                    state.processingInProgress = false;
                    })
                    .catch(error => {
                    console.error("[DEBUG] Error processing audio file:", error);
                    alert("An error occurred while processing the audio file.");

                    // --- CHANGEMENT 3 : GÉRER L'ÉCHEC ---\
                    window.setRingPercentage(0); // Réinitialiser l'anneau\
                    window.toggleMode('upload');   // Revenir à l'écran d'upload\
                    // ------------------------------------\

                    state.processingInProgress = false;
                    });
                    })
                    .catch(err => {
                    console.error("[DEBUG] Error converting file:", err);
                    alert("An error occurred while preparing the audio file.");
                    window.setRingPercentage(0);
                    window.toggleMode('upload');
                    state.processingInProgress = false;
                    });
                    };

                    reader.onerror = function() {
                    console.error("[DEBUG] Error reading file:", reader.error);
                    alert("An error occurred while reading the audio file.");
                    window.setRingPercentage(0);
                    window.toggleMode('upload');
                    state.processingInProgress = false;
                    };

                    reader.readAsArrayBuffer(state.uploadedFile);
                    };

                    // Handle file selection
                    window.handleFileSelect = function(event) {
                    event.preventDefault();
                    event.stopPropagation();

                    // Get file from input or drop event
                    let files;
                    if (event.dataTransfer) {
                    files = event.dataTransfer.files; // From drag & drop
                    } else {
                    files = event.target.files; // From file input
                    }

                    if (!files || files.length === 0) {
                    console.log("[DEBUG] No files selected");
                    return;
                    }

                    const file = files[0];

                    // Check if it's an audio file
                    if (!file.type.match('audio.*') && !file.name.match(/\\.(m4a|caf|mp3|aac|wav)$/i)) {
                    alert('Please select an audio file.');
                    return;
                    }

                    // Store file in global state
                    window.recordingState.uploadedFile = file;

                    // Update UI
                    const fileName = document.getElementById('fileName');
                    const fileSize = document.getElementById('fileSize');
                    const fileInfo = document.getElementById('fileInfo');
                    const formatWarning = document.getElementById('formatWarning');

                    if (fileName) fileName.textContent = file.name;
                    if (fileSize) fileSize.textContent = window.formatFileSize(file.size);
                    if (fileInfo) fileInfo.style.display = 'block';

                    // Check format compatibility with iOS
                    const fileExtension = file.name.split('.').pop().toLowerCase();
                    if (formatWarning) {
                    if (['m4a', 'mp3', 'aac'].includes(fileExtension)) {
                    formatWarning.style.display = 'none';
                    } else {
                    formatWarning.style.display = 'block';
                    }
                    }

                    console.log(`[DEBUG] File selected: ${file.name} (${window.formatFileSize(file.size)})`);
                    };

                    // Format file size for display
                    window.formatFileSize = function(bytes) {
                    if (bytes < 1024) return bytes + ' B';
                    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                    };

                    // Format time for audio display
                    window.formatTime = function(seconds) {
                    if (isNaN(seconds) || !isFinite(seconds)) return "0:00";
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = Math.floor(seconds % 60);
                    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
                    };

                    // Clear recording state
                    window.clearRecording = function(event) {
                    const state = window.recordingState;

                    state.audioBlob = null;
                    state.recordedChunks = [];
                    state.uploadedFile = null;
                    window.lastAudioBlob = null;

                    // Handle iOS-specific cleanup
                    if (state.isIOS) {
                    if (state.recordRTC) {
                    try {
                    state.recordRTC.stopRecording(function() {
                    state.recordRTC.destroy();
                    if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                    }
                    setTimeout(() => {
                    state.recordRTC = null;
                    state.stream = null;
                    }, 300);
                    });
                    } catch (e) {
                    console.log("[DEBUG] Error stopping RecordRTC:", e);
                    }
                    state.recordRTC = null;
                    }
                    } else {
                    // Standard cleanup
                    if (state.mediaRecorder && state.mediaRecorder.state !== "inactive") {
                    try {
                    state.mediaRecorder.stop();
                    } catch (e) {
                    console.log("[DEBUG] Error stopping mediaRecorder:", e);
                    }
                    }
                    state.mediaRecorder = null;
                    }

                    // Stop any active tracks
                    if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                    state.stream = null;
                    }

                    state.isRecording = false;

                    // Reset UI elements
                    const audioPlayback = document.getElementById("audioPlayback");
                    if (audioPlayback) { audioPlayback.src = ""; }

                    const audioProgressBar = document.getElementById("audioProgressBar");
                    if (audioProgressBar) { audioProgressBar.style.width = "0%"; }

                    const audioDuration = document.getElementById("audioDuration");
                    if (audioDuration) { audioDuration.textContent = "0:00 / 0:00"; }

                    window.stopRecordingFlash();
                    window.setRingPercentage(0);

                    const pb = document.getElementById("playButton");
                    if (pb) {
                    pb.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                    <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                    <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                  </svg>
                    `;
                    }

                    document.getElementById("retryProcessBtn").style.display = "none";

                    // Reset upload UI
                    const fileInfo = document.getElementById("fileInfo");
                    if (fileInfo) fileInfo.style.display = "none";

                    const formatWarning = document.getElementById("formatWarning");
                    if (formatWarning) formatWarning.style.display = "none";

                    const audioFileInput = document.getElementById("audioFileInput");
                    if (audioFileInput) audioFileInput.value = '';

                    // Update mobile UI if needed
                    window.updateMobileAudioDisplay();

                    console.log("[DEBUG] Recording cleared");
                    };

                    // Format document (Bold, Italic, etc.)
                    window.formatDoc = function(cmd) {
                    document.execCommand(cmd, false, null);
                    };

                    // Insert image in editor
                    window.insertImage = function() {
                    var input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = function(e) {
                    var file = e.target.files[0];
                    var reader = new FileReader();
                    reader.onload = function(event) {
                    var img = document.createElement('img');
                    img.src = event.target.result;
                    img.style.maxWidth = '100%';
                    img.dataset.referenceId = 'img_' + Date.now();
                    document.getElementById('editor').appendChild(img);
                    };
                    reader.readAsDataURL(file);
                    };
                    input.click();
                    };

                    // Copy editor content
                    window.copyEditorContent = function() {
                    const editor = document.getElementById('editor');
                    if (!editor) return;

                    const range = document.createRange();
                    range.selectNodeContents(editor);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);

                    try {
                    document.execCommand('copy');
                    window.displayBanner('Content copied!', 'success');
                    } catch (err) {
                    console.error('Error copying content', err);
                    }

                    selection.removeAllRanges();
                    };

                    // Toggle between recording and upload modes
                    window.toggleMode = function(mode) {
                    const recordingMode = document.getElementById('recordingMode');
                    const uploadMode = document.getElementById('uploadMode');
                    const recordButton = document.getElementById('recordButton');
                    const uploadButton = document.getElementById('uploadButton');

                    if (mode === 'record') {
                    if (recordingMode) recordingMode.style.display = 'block';
                    if (uploadMode) uploadMode.style.display = 'none';
                    if (recordButton) recordButton.classList.add('active');
                    if (uploadButton) uploadButton.classList.remove('active');
                    } else if (mode === 'upload') {
                    if (recordingMode) recordingMode.style.display = 'none';
                    if (uploadMode) uploadMode.style.display = 'block';
                    if (recordButton) recordButton.classList.remove('active');
                    if (uploadButton) uploadButton.classList.add('active');
                    }
                    };

                    window.saveContent = function(event) {
                    window._saveContentData = {
                    content: document.getElementById('editor').innerHTML,
                    images: Array.from(document.querySelectorAll('#editor img')).map(img => ({
                    media: img.src,
                    reference_id: img.dataset.referenceId || ('img_' + Date.now()),
                    position: img.offsetTop.toString()
                    }))
                    };
                    window.openPatientModalForSave();
                    };

                    // --------------------------------------------------------------------------------------------
                    // GOLDEN RULE 2: Always Attach Event Listeners on Load
                    // --------------------------------------------------------------------------------------------

                    window.__attachAudioManagerEvents = function() {
                    console.log("[DEBUG] ATTACHING AUDIO MANAGER EVENTS (FINAL ROBUST VERSION)");

                    // ===================================
                    // Section 1 : Main recording controls
                    // ===================================
                    const playButton = document.getElementById("playButton");
                    if (playButton) {
                    playButton.replaceWith(playButton.cloneNode(true));
                    document.getElementById("playButton").addEventListener("click", function(event) {
                    if (window.recordingState.isRecording) { window.pauseRecording(event); }
                    else {
                    if (window.recordingState.mediaRecorder && window.recordingState.mediaRecorder.state === "paused") { window.resumeRecording(event); }
                    else { window.startRecording(event); }
                    }
                    });
                    }

                    const stopButton = document.getElementById("stopButton");
                    if (stopButton) {
                    stopButton.replaceWith(stopButton.cloneNode(true));
                    document.getElementById("stopButton").addEventListener("click", function(event) {
                    window.stopRecording(event);
                    });
                    }

                    // ===================================
                    // Section 2 : Mode toggle and file upload
                    // ===================================
                    const recordToggleBtn = document.getElementById("recordButton");
                    if (recordToggleBtn) {
                    recordToggleBtn.replaceWith(recordToggleBtn.cloneNode(true));
                    document.getElementById("recordButton").addEventListener('click', () => window.toggleMode('record'));
                    }

                    const uploadToggleBtn = document.getElementById("uploadButton");
                    if (uploadToggleBtn) {
                    uploadToggleBtn.replaceWith(uploadToggleBtn.cloneNode(true));
                    document.getElementById("uploadButton").addEventListener('click', () => window.toggleMode('upload'));
                    }

                    // ----------------------------------------------------
                    // CORRECTED UPLOAD LOGIC
                    // ----------------------------------------------------

                    // A. Handle the drop zone and its children using a "guard flag"
                    const dropZone = document.getElementById("dropZone");
                    if (dropZone && !dropZone.dataset.listenersAttached) {
                      console.log("[DEBUG] Attaching listeners to dropZone for the first time.");

                      // Attach drag-and-drop listeners directly
                      dropZone.addEventListener('dragover', e => { e.preventDefault(); e.stopPropagation(); dropZone.classList.add('dragover'); });
                      dropZone.addEventListener('dragleave', e => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover'); });
                      dropZone.addEventListener('drop', e => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover'); window.handleFileSelect(e); });

                      // Handle clicks on the drop zone to trigger the file input
                      dropZone.addEventListener('click', function(event) {
                        // If the user clicks on the "Select file" button/label, let the browser handle it
                        if (event.target.tagName === 'LABEL' || event.target.closest('label.upload-button')) {
                          return;
                        }
                        // Otherwise, programmatically click the file input
                        const currentFileInput = document.getElementById('audioFileInput');
                        if (currentFileInput) currentFileInput.click();
                      });

                      // Crucially, attach the 'change' listener to the file input that is already in the DOM
                      const audioFileInput = document.getElementById("audioFileInput");
                      if (audioFileInput) {
                          audioFileInput.addEventListener('change', function(event) {
                              console.log("File selected via input. Calling handleFileSelect...");
                              window.handleFileSelect(event);
                          });
                      }

                      // Set the flag to prevent re-attaching these listeners
                      dropZone.dataset.listenersAttached = "true";
                    }


                    // B. Handle the "Process" and "Remove" buttons (can still use cloning safely)
                    const processFileButton = document.getElementById("processFileButton");
                    if (processFileButton) {
                    processFileButton.replaceWith(processFileButton.cloneNode(true));
                    document.getElementById("processFileButton").addEventListener('click', window.processUploadedFile);
                    }

                    const removeFileButton = document.getElementById("removeFileButton");
                    if (removeFileButton) {
                    removeFileButton.replaceWith(removeFileButton.cloneNode(true));
                    document.getElementById("removeFileButton").addEventListener('click', window.clearRecording);
                    }

                    // Editor toolbar buttons
                    const boldBtn = document.getElementById("boldBtn");
                    const italicBtn = document.getElementById("italicBtn");
                    const underlineBtn = document.getElementById("underlineBtn");
                    const leftAlignBtn = document.getElementById("leftAlignBtn");
                    const centerAlignBtn = document.getElementById("centerAlignBtn");
                    const rightAlignBtn = document.getElementById("rightAlignBtn");
                    const insertImageBtn = document.getElementById("insertImageBtn");
                    const copyBtn = document.getElementById("copyBtn");

                    if (boldBtn) {
                    boldBtn.replaceWith(boldBtn.cloneNode(true));
                    const newBoldBtn = document.getElementById("boldBtn");
                    newBoldBtn.addEventListener('click', function() {
                    window.formatDoc('bold');
                    });
                    }

                    if (italicBtn) {
                    italicBtn.replaceWith(italicBtn.cloneNode(true));
                    const newItalicBtn = document.getElementById("italicBtn");
                    newItalicBtn.addEventListener('click', function() {
                    window.formatDoc('italic');
                    });
                    }

                    if (underlineBtn) {
                    underlineBtn.replaceWith(underlineBtn.cloneNode(true));
                    const newUnderlineBtn = document.getElementById("underlineBtn");
                    newUnderlineBtn.addEventListener('click', function() {
                    window.formatDoc('underline');
                    });
                    }

                    if (leftAlignBtn) {
                    leftAlignBtn.replaceWith(leftAlignBtn.cloneNode(true));
                    const newLeftAlignBtn = document.getElementById("leftAlignBtn");
                    newLeftAlignBtn.addEventListener('click', function() {
                    window.formatDoc('justifyleft');
                    });
                    }

                    if (centerAlignBtn) {
                    centerAlignBtn.replaceWith(centerAlignBtn.cloneNode(true));
                    const newCenterAlignBtn = document.getElementById("centerAlignBtn");
                    newCenterAlignBtn.addEventListener('click', function() {
                    window.formatDoc('justifycenter');
                    });
                    }

                    if (rightAlignBtn) {
                    rightAlignBtn.replaceWith(rightAlignBtn.cloneNode(true));
                    const newRightAlignBtn = document.getElementById("rightAlignBtn");
                    newRightAlignBtn.addEventListener('click', function() {
                    window.formatDoc('justifyright');
                    });
                    }

                    if (insertImageBtn) {
                    insertImageBtn.replaceWith(insertImageBtn.cloneNode(true));
                    const newInsertImageBtn = document.getElementById("insertImageBtn");
                    newInsertImageBtn.addEventListener('click', function() {
                    window.insertImage();
                    });
                    }

                    if (copyBtn) {
                    copyBtn.replaceWith(copyBtn.cloneNode(true));
                    const newCopyBtn = document.getElementById("copyBtn");
                    newCopyBtn.addEventListener('click', function() {
                    window.copyEditorContent();
                    });
                    }

                    // Toolbar recording related buttons
                    const startToolbarRecBtn = document.getElementById('startToolbarRecBtn');
                    if (startToolbarRecBtn) {
                    startToolbarRecBtn.replaceWith(startToolbarRecBtn.cloneNode(true));
                    const newToolbarRecButton = document.getElementById('startToolbarRecBtn');

                    newToolbarRecButton.addEventListener('click', function(event) {
                    window.startToolbarRecording(event);
                    });
                    }

                    // Validate button
                    const validateBtn = document.getElementById("validateBtn");
                    if (validateBtn) {
                    validateBtn.replaceWith(validateBtn.cloneNode(true));
                    const newValidateButton = document.getElementById("validateBtn");

                    newValidateButton.addEventListener('click', function(event) {
                    // The validate button also finalizes any ongoing toolbar recording
                    newValidateButton.classList.add("tb-processing-flash");

                    // If a toolbar recording is in progress, finalize it first
                    window.finalizeToolbarRecording()
                    .then(() => {
                    // Then call the normal validation server method
                    return anvil.call(event.target, "validate_and_send");
                    })
                    .then(() => {
                    // Once done, remove the processing flash
                    newValidateButton.classList.remove("tb-processing-flash");
                    })
                    .catch((err) => {
                    console.error("[DEBUG] Error finalizing or validating:", err);
                    newValidateButton.classList.remove("tb-processing-flash");
                    });
                    });
                    }

                    // Template selection
                    const templateSelectBtn = document.getElementById("templateSelectBtn");
                    if (templateSelectBtn) {
                    templateSelectBtn.replaceWith(templateSelectBtn.cloneNode(true));
                    const newTemplateSelectBtn = document.getElementById("templateSelectBtn");

                    newTemplateSelectBtn.addEventListener("click", function() {
                    window.openTemplateModal();
                    });
                    }

                    // Template search
                    const templateSearchInput = document.getElementById("templateSearchInput");
                    if (templateSearchInput) {
                    templateSearchInput.replaceWith(templateSearchInput.cloneNode(true));
                    const newTemplateSearchInput = document.getElementById("templateSearchInput");

                    newTemplateSearchInput.addEventListener('input', function(event) {
                    window.searchTemplatesInModal(event.target.value);
                    });
                    }

                    // Template modal close button
                    const closeTemplateModalBtn = document.getElementById("closeTemplateModalBtn");
                    if (closeTemplateModalBtn) {
                    closeTemplateModalBtn.replaceWith(closeTemplateModalBtn.cloneNode(true));
                    const newCloseTemplateBtn = document.getElementById("closeTemplateModalBtn");

                    newCloseTemplateBtn.addEventListener('click', function() {
                    window.closeTemplateModal();
                    });
                    }

                    // Patient modal buttons
                    const closePatientModalBtn = document.getElementById("closePatientModalBtn");
                    if (closePatientModalBtn) {
                    closePatientModalBtn.replaceWith(closePatientModalBtn.cloneNode(true));
                    const newClosePatientBtn = document.getElementById("closePatientModalBtn");

                    newClosePatientBtn.addEventListener('click', function() {
                    window.closePatientModal();
                    });
                    }

                    const newPatientBtn = document.getElementById("newPatientBtn");
                    if (newPatientBtn) {
                    newPatientBtn.replaceWith(newPatientBtn.cloneNode(true));
                    const newNewPatientBtn = document.getElementById("newPatientBtn");

                    newNewPatientBtn.addEventListener('click', function() {
                    window.newPatientForSave();
                    });
                    }

                    // Language dropdown
                    const allDropdowns = document.querySelectorAll('.dropdown');
                    allDropdowns.forEach(dd => {
                    // Remove existing handlers
                    const newDD = dd.cloneNode(true);
                    dd.parentNode.replaceChild(newDD, dd);

                    newDD.addEventListener('click', function(e) {
                    const menu = newDD.querySelector('.dropdown-menu');
                    if (!menu || e.target.closest('.dropdown-menu')) return;

                    menu.classList.toggle('active');
                    });

                    const dropdownItems = newDD.querySelectorAll('.dropdown-menu div');
                    dropdownItems.forEach(item => {
                    item.addEventListener('click', function(ev) {
                    ev.stopPropagation();
                    const selectedValue = ev.target.getAttribute('data-value');
                    if (selectedValue) {
                    const displaySpan = newDD.querySelector('span:first-child');
                    if (displaySpan) {
                    displaySpan.textContent = selectedValue;
                    }
                    const menu = newDD.querySelector('.dropdown-menu');
                    if (menu) menu.classList.remove('active');
                    }
                    });
                    });
                    });

                    // Nav tabs
                    const navTabs = document.querySelectorAll('.nav-tab');
                    navTabs.forEach(tab => {
                    // Remove existing handlers
                    const newTab = tab.cloneNode(true);
                    tab.parentNode.replaceChild(newTab, tab);

                    newTab.addEventListener('click', function(e) {
                    const action = e.target.dataset.click;
                    if (action === 'production') {
                    anvil.call(e.target, 'open_production_form');
                    } else if (action === 'templates') {
                    anvil.call(e.target, 'open_templates_form');
                    } else if (action === 'archives') {
                    anvil.call(e.target, 'open_archives_form');
                    } else if (action === 'settings') {
                    anvil.call(e.target, 'open_settings_form');
                    }
                    });
                    });

                    // Bottom buttons
                    const bottomButtons = document.querySelectorAll('.bottom-button');
                    bottomButtons.forEach(btn => {
                    // Remove existing handlers
                    const newBtn = btn.cloneNode(true);
                    btn.parentNode.replaceChild(newBtn, btn);

                    newBtn.addEventListener('click', function(e) {
                    const action = e.target.dataset.click;
                    if (action === 'statut') {
                    anvil.call(e.target, 'on_statut_clicked')
                    .then(function(chosenStatus) {
                    if (chosenStatus) {
                    e.target.textContent = chosenStatus;
                    }
                    })
                    .catch(function(error) {
                    console.error("[DEBUG] Error in status handling:", error);
                    });
                    } else if (action === 'enregistrer') {
                    window.saveContent(e);
                    } else if (action === 'partager') {
                    console.log("Share triggered!");
                    window.displayBanner("Feature under development by the Checkvet team", "success");
                    }
                    });
                    });

                    // Session refresh handlers
                    window.addEventListener('online', function() {
                    console.log("[DEBUG] Application back online, refreshing session");
                    anvil.call(document.body, 'refresh_session_relay');
                    });

                    document.addEventListener('visibilitychange', function() {
                    if (document.visibilityState === 'visible') {
                    console.log("[DEBUG] Application visible again, checking session");
                    anvil.call(document.body, 'refresh_session_relay');
                    }
                    });

                    // Listen for visibility changes to re-request wake lock
                    document.addEventListener('visibilitychange', function() {
                    if (document.visibilityState === 'visible' && window.wakeLockController) {
                    window.wakeLockController.requestWakeLock();
                    }
                    });

                    // Check for iOS and set up iOS-specific enhancements
                    if (window.recordingState.isIOS) {
                    window.setupIOSSupport();
                    }

                    // Update time on load
                    window.updateTime();

                    // Initial wake lock request
                    window.wakeLockController.requestWakeLock();

                    console.log(`[DEBUG] Audio manager event listeners attached. iOS detection: ${window.recordingState.isIOS}`);
                    };

                    // Set up regular time updates
                    setInterval(window.updateTime, 60000);
                    }

                    // --------------------------------------------------------------------------------------------
                    // GOLDEN RULE 3: Immediately Attach Everything
                    // --------------------------------------------------------------------------------------------
                    window.__attachAudioManagerEvents();

                    // Add some debug output to help identify initialization issues
                    console.log("[DEBUG JS] Audio manager script loaded and initialized");
                    console.log("[DEBUG JS] Key functions:", {
                    rebuildPatientSearchInput: typeof window.rebuildPatientSearchInput === 'function' ? 'defined' : 'undefined',
                    renderTemplates: typeof window.renderTemplates === 'function' ? 'defined' : 'undefined',
                    populateTemplateModal: typeof window.populateTemplateModal === 'function' ? 'defined' : 'undefined'
                    });
                </script>
              </body>
            </html>
        type: HtmlTemplate
      is_package: true
  type: HtmlTemplate
is_package: true
