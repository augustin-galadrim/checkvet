components: []
container:
  properties:
    html: |-
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <!-- Responsive for mobile devices -->
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Audio Management Interface</title>

          <!-- Add RecordRTC for iOS compatibility -->
          <script src="https://www.webrtc-experiment.com/RecordRTC.js"></script>

          <!-- Add NoSleep.js for fallback wake lock on older browsers -->
          <script src="https://cdnjs.cloudflare.com/ajax/libs/nosleep/0.12.0/NoSleep.min.js"></script>

          <style>
            /* =====================================================
            Basic styles
            ===================================================== */
            * {
              box-sizing: border-box;
              font-family: Arial, sans-serif;
              margin: 0;
              padding: 0;
            }
            body {
              background-color: #f5f5f5;
              height: 100vh;
              overflow: hidden;
            }
            .container {
              display: flex;
              flex-direction: column;
              height: 100vh;
              width: 100%;
              max-width: 800px;
              margin: 0 auto;
              background-color: white;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            /* =====================================================
            Fixed section (tabs + actions)
            ===================================================== */
            .fixed-section {
              background: white;
              z-index: 10;
            }
            .nav-tabs {
              display: flex;
              width: 100%;
              border-bottom: 1px solid #ddd;
            }
            .nav-tab {
              flex: 1;
              padding: 8px 16px;
              cursor: pointer;
              border: 1px solid #ccc;
              border-bottom: none;
              background: #f8f8f8;
              font-size: 14px;
              position: relative;
              margin-right: -1px;
              text-align: center;
            }
            .nav-tab.active {
              background: #e5e5e5;
              border-top: 1px solid #999;
              border-left: 1px solid #999;
              border-right: 1px solid #999;
              border-bottom: 1px solid #e5e5e5;
              margin-bottom: -1px;
            }
            .actions-row {
              display: flex;
              justify-content: flex-end;
              align-items: center;
              padding: 15px 20px;
            }
            .time {
              color: #666;
              font-size: 14px;
            }
            /* =====================================================
            Scrollable content
            ===================================================== */
            .scrollable-content {
              flex: 1;
              overflow-y: auto;
              padding: 20px;
              padding-bottom: 80px;
              -webkit-overflow-scrolling: touch;
            }

            /* =====================================================
            AUDIO section (playback + recording)
            ===================================================== */
            .audio-section {
              background: white;
              padding: 20px;
              border-radius: 8px;
              margin-bottom: 20px;
              position: relative;
            }
            #audioBar {
              width: 100%;
              height: 50px;
              background-color: #f8f8f8;
              border-radius: 5px;
              display: flex;
              align-items: center;
              padding: 0 10px;
              margin-bottom: 20px;
              border: 1px solid #ddd;
              position: relative;
            }
            /* PC Controls */
            #audioPlaybackControl {
              width: 30px;
              height: 30px;
              background-color: #4CAF50;
              border: none;
              border-radius: 50%;
              color: white;
              font-size: 16px;
              cursor: pointer;
              margin-right: 10px;
            }
            #audioProgress {
              flex-grow: 1;
              height: 10px;
              background-color: #ddd;
              border-radius: 5px;
              overflow: hidden;
              cursor: pointer;
              margin-right: 10px;
              touch-action: none;
            }
            #audioProgressBar {
              width: 0;
              height: 100%;
              background-color: #4CAF50;
              transition: width 0.1s linear;
            }
            #audioDuration {
              font-size: 14px;
            }
            #clearRecordingButton {
              background: none;
              border: none;
              font-size: 18px;
              cursor: pointer;
              color: #666;
              margin-left: 10px;
            }
            #clearRecordingButton:hover {
              color: #000;
            }
            #retryProcessBtn {
              position: absolute;
              top: -40px;
              right: 10px;
              padding: 8px 12px;
              background-color: #4caf50;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              display: none;
            }
            .recording-controls {
              position: relative;
              width: 200px;
              height: 200px;
              margin: 20px auto;
            }
            #circularProgress {
              position: relative;
              width: 200px;
              height: 200px;
              margin: 0 auto;
              border-radius: 50%;
              overflow: hidden;
            }
            #progressRing {
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              border-radius: 50%;
              background: conic-gradient(#ddd 0deg, #ddd 0deg);
            }
            #centerHole {
              position: absolute;
              top: 8px;
              left: 8px;
              width: 184px;
              height: 184px;
              background-color: #fff;
              border-radius: 50%;
              z-index: 1;
            }
            .control-button-group {
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              display: flex;
              gap: 30px;
              z-index: 2;
            }
            .control-button {
              width: 45px;
              height: 45px;
              border: 1px solid #666;
              border-radius: 2px;
              cursor: pointer;
              background-color: white;
              color: #666;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 24px;
              transition: all 0.3s ease;
              padding: 0;
            }
            .control-button svg {
              pointer-events: none;
            }
            .control-button:hover {
              background-color: #f5f5f5;
              border-color: #333;
              color: #333;
            }

            /* =====================================================
            Upload Voice Memo Section for all devices
            ===================================================== */
            .upload-section {
              margin: 20px auto;
              max-width: 400px;
              position: relative;
              display: flex;
              flex-direction: column;
              align-items: center;
            }

            .upload-container {
              width: 100%;
              border: 2px dashed #aaa;
              border-radius: 10px;
              padding: 20px;
              text-align: center;
              background-color: #f8f8f8;
              transition: all 0.3s ease;
              cursor: pointer;
              margin-bottom: 15px;
            }

            .upload-container:hover {
              border-color: #4CAF50;
              background-color: #f0f9f0;
            }

            .upload-container.dragover {
              border-color: #4CAF50;
              background-color: #e7f6e7;
              transform: scale(1.02);
            }

            .upload-icon {
              font-size: 40px;
              color: #666;
              margin-bottom: 10px;
            }

            .upload-text {
              color: #333;
              font-size: 16px;
              margin-bottom: 5px;
            }

            .upload-description {
              color: #666;
              font-size: 14px;
              margin-bottom: 15px;
            }

            .upload-button {
              background-color: #4CAF50;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 5px;
              font-size: 16px;
              cursor: pointer;
              transition: background-color 0.3s;
              min-height: 44px; /* iOS minimum touch target size */
            }

            .upload-button:hover {
              background-color: #45a049;
            }

            .upload-button:active {
              transform: scale(0.98);
              opacity: 0.9;
            }

            #audioFileInput {
              display: none;
            }

            .file-info {
              display: none;
              margin-top: 15px;
              padding: 10px;
              background-color: #e8f5e9;
              border-radius: 5px;
              width: 100%;
              font-size: 14px;
            }

            .file-name {
              font-weight: bold;
              word-break: break-all;
            }

            .file-size {
              color: #666;
            }

            .file-actions {
              display: flex;
              justify-content: space-between;
              margin-top: 10px;
            }

            .file-button {
              padding: 5px 10px;
              border-radius: 3px;
              border: none;
              font-size: 14px;
              cursor: pointer;
              min-height: 36px;
            }

            .process-file-button {
              background-color: #4CAF50;
              color: white;
            }

            .remove-file-button {
              background-color: #f44336;
              color: white;
            }

            .format-warning {
              display: none;
              margin-top: 10px;
              padding: 8px;
              background-color: #fff3e0;
              border-left: 4px solid #ff9800;
              font-size: 13px;
              color: #6d4c41;
            }

            /* iOS-specific guidance */
            .ios-instructions {
              margin: 15px 0;
              padding: 15px;
              background-color: #f8f9fa;
              border-left: 4px solid #007aff;
              border-radius: 4px;
              font-size: 14px;
              display: none; /* Hidden by default, shown by JS for iOS */
            }

            .ios-instructions h4 {
              color: #007aff;
              margin-top: 0;
              margin-bottom: 10px;
            }

            .ios-instructions ol {
              padding-left: 20px;
            }

            .ios-instructions li {
              margin-bottom: 8px;
            }

            /* Toggle between upload and recording */
            .mode-toggle {
              display: flex;
              justify-content: center;
              margin-bottom: 20px;
              border-bottom: 1px solid #eee;
              padding-bottom: 15px;
            }

            .toggle-button {
              padding: 8px 16px;
              margin: 0 5px;
              background-color: #f1f1f1;
              border: 1px solid #ddd;
              border-radius: 20px;
              font-size: 14px;
              cursor: pointer;
              transition: all 0.3s ease;
            }

            .toggle-button.active {
              background-color: #4CAF50;
              color: white;
              border-color: #4CAF50;
            }

            @keyframes recordingFlash {
              0% { background: conic-gradient(#ffe5e5 0deg, #ffe5e5 360deg); }
              50% { background: conic-gradient(#ffffff 0deg, #ffffff 360deg); }
              100% { background: conic-gradient(#ffe5e5 0deg, #ffe5e5 360deg); }
            }
            .recording-flash {
              animation: recordingFlash 1.5s infinite;
            }
            /* Mobile audio display (only on mobile) */
            #mobileAudioDisplay {
              display: none;
              width: 100%;
              text-align: center;
              font-size: 16px;
              font-weight: bold;
              color: #333;
            }

            /* =====================================================
            Settings Section
            ===================================================== */
            .parameters-section {
              background: white;
              padding: 20px;
              border-radius: 8px;
              margin-bottom: 20px;
            }
            .parameter-row {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 15px;
            }
            .parameter-row label {
              font-weight: bold;
              margin-right: 10px;
            }
            .template-select-container .select-button {
              min-width: 200px;
              padding: 8px;
              border: 1px solid #ddd;
              border-radius: 4px;
              background: white;
              cursor: pointer;
              display: flex;
              justify-content: space-between;
              align-items: center;
              font-size: 14px;
            }
            .dropdown {
              min-width: 200px;
              padding: 8px;
              border: 1px solid #ddd;
              border-radius: 4px;
              background: white;
              cursor: pointer;
              position: relative;
              display: flex;
              justify-content: space-between;
              align-items: center;
            }
            .arrow { margin-left: 10px; color: #666; }
            .dropdown-menu {
              position: absolute;
              top: 100%;
              left: 0;
              width: 100%;
              background: white;
              border: 1px solid #ddd;
              border-radius: 4px;
              display: none;
              z-index: 1000;
            }
            .dropdown-menu.active { display: block; }
            .dropdown-menu div {
              padding: 8px;
              cursor: pointer;
            }
            .dropdown-menu div:hover { background: #f5f5f5; }
            /* =====================================================
            Editor Section
            ===================================================== */
            .editor-section {
              background: white;
              border-radius: 8px;
              overflow: hidden;
            }
            #toolbar {
              padding: 10px;
              background: #f8f8f8;
              border-bottom: 1px solid #ddd;
              display: flex;
              flex-wrap: wrap;
              gap: 5px;
              align-items: center;
            }
            .toolbar-button {
              padding: 6px 12px;
              border: 1px solid #ddd;
              border-radius: 4px;
              background: white;
              cursor: pointer;
            }
            .toolbar-button:hover { background: #f5f5f5; }

            /* Single highlight for the "Start TB Rec" button while recording: */
            .tb-recording-flash {
              background-color: #ffebe6 !important;
              border-color: #ff6347 !important;
              color: #ff6347 !important;
            }

            /* Highlight for "Validate" button while AI processes snippet: */
            .tb-processing-flash {
              background-color: #e6ffe6 !important;
              border-color: #4CAF50 !important;
              color: #4CAF50 !important;
            }

            .toolbar-button.recording {
              background-color: #ffebe6;
              border-color: #ff6347;
              color: #ff6347;
            }
            .toolbar-button.validate {
              background-color: #e6ffe6;
              border-color: #4CAF50;
              color: #4CAF50;
            }
            #editor {
              min-height: 300px;
              padding: 20px;
              border: 1px solid #ddd;
              overflow-y: auto;
              font-size: 16px;
              line-height: 1.5;
            }
            .scrollable-content::-webkit-scrollbar { width: 8px; }
            .scrollable-content::-webkit-scrollbar-track { background: #f1f1f1; }
            .scrollable-content::-webkit-scrollbar-thumb {
              background: #888;
              border-radius: 4px;
            }
            .scrollable-content::-webkit-scrollbar-thumb:hover { background: #555; }

            /* =====================================================
            Bottom buttons
            ===================================================== */
            .bottom-buttons {
              position: fixed;
              bottom: 0;
              left: 50%;
              transform: translateX(-50%);
              width: 800px;
              max-width: 100%;
              background: white;
              padding: 15px 20px;
              display: flex;
              justify-content: center;
              gap: 20px;
              border-top: 1px solid #ddd;
              box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
              z-index: 10;
            }
            .bottom-button {
              padding: 10px 30px;
              border: 1px solid #ddd;
              border-radius: 4px;
              background: white;
              cursor: pointer;
              font-size: 14px;
              transition: all 0.2s ease;
            }
            .bottom-button:hover {
              background: #f5f5f5;
              border-color: #999;
            }

            /* =====================================================
            Patient selection modal (for saving)
            ===================================================== */
            .patient-select-container {
              position: relative;
              width: 300px;
              font-family: system-ui, -apple-system, sans-serif;
            }
            .select-button#patientSelectBtn { display: none; }
            .modal {
              display: none;
              position: fixed;
              top: 0; left: 0;
              width: 100%; height: 100%;
              background-color: rgba(0, 0, 0, 0.5);
              z-index: 1000;
            }
            .modal-content {
              position: relative;
              background-color: white;
              margin: 15% auto;
              padding: 20px;
              width: 90%;
              max-width: 400px;
              border-radius: 8px;
              box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }
            .modal-header { margin-bottom: 20px; }
            .modal-title {
              font-size: 18px;
              font-weight: 600;
              margin: 0 0 15px 0;
            }
            .search-container { position: relative; margin-bottom: 20px; }
            .search-icon {
              position: absolute;
              left: 12px;
              top: 50%;
              transform: translateY(-50%);
              width: 16px;
              height: 16px;
              color: #666;
            }
            #patientSearchHolder {
              /* Container rebuilt dynamically */
            }
            .search-input {
              width: 100%;
              padding: 8px 12px 8px 36px;
              border: 1px solid #ddd;
              border-radius: 6px;
              font-size: 14px;
              box-sizing: border-box;
            }
            .search-input:focus {
              outline: none;
              border-color: #2563eb;
              box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
            }
            .new-patient-btn {
              display: flex;
              align-items: center;
              gap: 8px;
              width: 100%;
              padding: 8px 12px;
              background: none;
              border: none;
              border-radius: 6px;
              color: #16a34a;
              cursor: pointer;
              font-size: 14px;
              text-align: left;
            }
            .new-patient-btn:hover { background-color: #f0fdf4; }
            .divider {
              height: 1px;
              background-color: #ddd;
              margin: 15px 0;
            }
            .patients-list { max-height: 200px; overflow-y: auto; }
            .patient-item {
              display: block;
              width: 100%;
              padding: 8px 12px;
              background: none;
              border: none;
              border-radius: 6px;
              text-align: left;
              cursor: pointer;
              font-size: 14px;
              color: #333;
            }
            .patient-item:hover { background-color: #f3f4f6; }
            .close-button {
              position: absolute;
              top: 15px;
              right: 15px;
              background: none;
              border: none;
              cursor: pointer;
              padding: 5px;
              color: #666;
            }

            /* =====================================================
            Template selection modal
            ===================================================== */
            .template-select-container .modal {
              z-index: 1100;
            }
            #templateModal {
              display: none;
              position: fixed;
              top: 0; left: 0;
              width: 100%; height: 100%;
              background-color: rgba(0, 0, 0, 0.5);
            }
            #templateModal .modal-content {
              margin: 15% auto;
              padding: 20px;
              width: 90%;
              max-width: 400px;
              border-radius: 8px;
              box-shadow: 0 4px 6px rgba(0,0,0,0.1);
              position: relative;
            }
            #templateModal .modal-header { margin-bottom: 20px; }
            #templateModal .modal-title {
              font-size: 18px;
              font-weight: 600;
              margin: 0 0 15px 0;
            }
            #templateModal .search-container { position: relative; margin-bottom: 20px; }
            #templateModal .search-icon {
              position: absolute;
              left: 12px;
              top: 50%;
              transform: translateY(-50%);
              width: 16px;
              height: 16px;
              color: #666;
            }
            #templateModal .search-input {
              width: 100%;
              padding: 8px 12px 8px 36px;
              border: 1px solid #ddd;
              border-radius: 6px;
              font-size: 14px;
              box-sizing: border-box;
            }
            #templateModal .templates-list { max-height: 300px; overflow-y: auto; }
            #templateModal .template-item {
              display: flex;
              justify-content: space-between;
              align-items: center;
              width: 100%;
              padding: 8px 12px;
              background: none;
              border: none;
              border-radius: 6px;
              text-align: left;
              cursor: pointer;
              font-size: 14px;
              color: #333;
            }
            #templateModal .template-item:hover { background: #f3f4f6; }
            #templateModal .star-icon {
              font-size: 16px;
              line-height: 1;
            }
            #templateModal .close-button {
              position: absolute;
              top: 15px;
              right: 15px;
              background: none;
              border: none;
              cursor: pointer;
              padding: 5px;
              color: #666;
            }

            /* =====================================================
            Banners (temporary messages)
            ===================================================== */
            #bannerContainer {
              position: fixed;
              top: 20px;
              left: 50%;
              transform: translateX(-50%);
              z-index: 2000;
            }
            /* Flashing banner to indicate ongoing toolbar recording.
            We'll toggle .flash-state every second for a "blink" effect. */
            .banner-flash {
              background-color: #f44336;
              margin-bottom: 10px;
              padding: 10px 20px;
              border-radius: 4px;
              color: #fff;
              opacity: 0.9;
              font-size: 14px;
              min-width: 200px;
              text-align: center;
              transition: background-color 0.3s ease;
            }
            .banner-flash.flash-state {
              background-color: #ff7961;
            }

            .banner {
              margin-bottom: 10px;
              padding: 10px 20px;
              border-radius: 4px;
              color: #fff;
              opacity: 0.9;
              font-size: 14px;
              min-width: 200px;
              text-align: center;
            }
            .banner-success {
              background-color: #4caf50;
            }
            .banner-error {
              background-color: #f44336;
            }

            /* =====================================================
            Responsive design (mobile)
            ===================================================== */
            @media (max-width: 800px) {
              .container {
                height: 100vh;
              }
              .bottom-buttons {
                width: 100%;
                left: 0;
                transform: none;
              }
              .nav-tab {
                font-size: 12px;
                padding: 6px 8px;
              }
              .actions-row {
                padding: 10px 15px;
              }
              #audioBar {
                height: auto;
                padding: 10px;
                display: flex;
                justify-content: center;
                align-items: center;
              }
              #audioPlaybackControl,
              #audioProgress,
              #audioDuration,
              #clearRecordingButton {
                display: none;
              }
              #mobileAudioDisplay {
                display: block;
              }
              .recording-controls {
                width: 180px;
                height: 180px;
              }
              #circularProgress {
                width: 180px;
                height: 180px;
              }
              #centerHole {
                top: 7px;
                left: 7px;
                width: 166px;
                height: 166px;
              }

              /* Enhanced Upload mode on mobile */
              .upload-section {
                margin-top: 10px;
              }
              .mode-toggle {
                margin-bottom: 10px;
                padding-bottom: 10px;
              }
              .toggle-button {
                font-size: 13px;
                padding: 6px 12px;
              }

              /* iOS-specific adjustments */
              @supports (-webkit-touch-callout: none) {
                /* Make buttons larger for better touch targets on iOS */
                .upload-button, .file-button, .toggle-button {
                  padding: 12px 20px;
                  min-height: 44px; /* iOS minimum recommended touch target size */
                  font-size: 16px; /* Prevent zoom on focus in iOS */
                }
              }
            }
          </style>
        </head>
        <body>
          <div class="container">
            <!-- Fixed section: Tabs + Actions -->
            <div class="fixed-section">
              <div class="nav-tabs">
                <button class="nav-tab active" data-click="production" id="nav_production">Production</button>
                <button class="nav-tab" data-click="templates" id="nav_templates">Templates/AI</button>
                <button class="nav-tab" data-click="archives" id="nav_archives">Archives</button>
                <button class="nav-tab" data-click="settings" id="nav_settings">Settings</button>
              </div>
              <div class="actions-row">
                <div class="time">11:44</div>
              </div>
            </div>

            <!-- Scrollable content -->
            <div class="scrollable-content">
              <!-- Audio Section (Playback + Recording) -->
              <div class="audio-section">
                <div id="audioBar">
                  <button id="audioPlaybackControl">â–¶</button>
                  <div id="audioProgress">
                    <div id="audioProgressBar"></div>
                  </div>
                  <span id="audioDuration">0:00 / 0:00</span>
                  <button id="clearRecordingButton" title="Reset recording">ðŸ—‘</button>
                  <button id="retryProcessBtn">Reprocess my audio with AI</button>
                  <div id="mobileAudioDisplay"></div>
                </div>

                <!-- Mode toggle -->
                <div class="mode-toggle">
                  <button id="recordButton" class="toggle-button active">Record</button>
                  <button id="uploadButton" class="toggle-button">Upload a voice memo</button>
                </div>

                <!-- Recording Mode -->
                <div class="recording-controls" id="recordingMode">
                  <div id="circularProgress">
                    <div id="progressRing"></div>
                    <div id="centerHole"></div>
                    <div class="control-button-group">
                      <button id="playButton" class="control-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                          <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                          <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                        </svg>
                      </button>
                      <button id="stopButton" class="control-button">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                          <path d="M4 12l5 5L20 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                      </button>
                    </div>
                  </div>
                </div>

                <!-- Upload Mode - Optimized for iOS -->
                <div class="upload-section" id="uploadMode" style="display: none;">
                  <div class="upload-container" id="dropZone">
                    <div class="upload-icon">ðŸ“‹</div>
                    <div class="upload-text" id="upload_text_drop">Drop your voice memo here</div>
                    <div class="upload-description" id="upload_description_select">or click to select a file</div>
                    <!-- File input with accept extended to include iOS formats -->
                    <input type="file" id="audioFileInput" accept="audio/*,.m4a,.caf">
                    <label for="audioFileInput" class="upload-button" id="upload_button_select">Select file</label>
                  </div>

                  <!-- Instructions for iOS (displayed only on iOS) -->
                  <div class="ios-instructions">
                    <h4>For iPhone users:</h4>
                    <p>To use your voice memos:</p>
                    <ol>
                      <li>Open the <strong>Files</strong> app on your iPhone</li>
                      <li>Locate the voice memo (it may be in <strong>On My iPhone > Voice Memos</strong>)</li>
                      <li>Tap and hold on the file to see options</li>
                      <li>Choose <strong>"Share"</strong></li>
                      <li>Select <strong>"Save to Files"</strong></li>
                      <li>Save it to an accessible location like <strong>iCloud Drive</strong></li>
                      <li>Return to this page and use the <strong>"Select file"</strong> button</li>
                    </ol>
                  </div>

                  <div class="file-info" id="fileInfo">
                    <div class="file-name" id="fileName">memo.m4a</div>
                    <div class="file-size" id="fileSize">2.4 MB</div>
                    <div class="file-actions">
                      <button class="file-button process-file-button" id="processFileButton">Process file</button>
                      <button class="file-button remove-file-button" id="removeFileButton">Remove</button>
                    </div>
                  </div>

                  <div class="format-warning" id="formatWarning">
                    This file format might not be compatible with iOS Voice Memos.
                    Recommended formats are: .m4a, .mp3, .aac
                  </div>
                </div>

                <audio id="audioPlayback" style="display: none;"></audio>
              </div>

              <!-- Settings Section -->
              <div class="parameters-section">
                <div class="parameter-row">
                  <label id="label_template">Template</label>
                  <div class="template-select-container">
                    <button class="select-button" id="templateSelectBtn">
                      <span id="select_template_placeholder">Select a template</span>
                      <span>â–¼</span>
                    </button>
                  </div>
                </div>
                <div class="parameter-row">
                  <label id="label_language">Language</label>
                  <div class="dropdown" id="langueDropdown">
                    <span>ðŸ‡¬ðŸ‡§</span>
                    <span class="arrow">â–¼</span>
                    <div class="dropdown-menu">
                      <div data-value="ðŸ‡«ðŸ‡·">ðŸ‡«ðŸ‡·</div>
                      <div data-value="ðŸ‡¬ðŸ‡§">ðŸ‡¬ðŸ‡§</div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Editor Section -->
              <div class="editor-section">
                <div id="toolbar">
                  <button class="toolbar-button" id="boldBtn"><b>B</b></button>
                  <button class="toolbar-button" id="italicBtn"><i>I</i></button>
                  <button class="toolbar-button" id="underlineBtn"><u>U</u></button>
                  <button class="toolbar-button" id="leftAlignBtn">Left</button>
                  <button class="toolbar-button" id="centerAlignBtn">Center</button>
                  <button class="toolbar-button" id="rightAlignBtn">Right</button>
                  <button class="toolbar-button" id="insertImageBtn" id="toolbar_image">Image</button>

                  <!-- SINGLE Start TB Rec button with mic icon only -->
                  <button class="toolbar-button recording" id="startToolbarRecBtn" title="Toolbar recording">ðŸŽ¤</button>

                  <!-- Validate button also finalizes any toolbar snippet if recording -->
                  <button class="toolbar-button validate" id="validateBtn" title="Validate and send">âœ“</button>

                  <span style="margin-left:auto;"></span>
                  <button class="toolbar-button" id="copyBtn" id="toolbar_copy">Copy</button>
                </div>
                <div id="editor" contenteditable="true"></div>
              </div>

              <!-- HIDDEN ANCHOR so we can call anvil.call() on a real child element -->
              <div id="toolbarRecorderAnchor" style="display:none;"></div>
            </div>

            <!-- Bottom buttons -->
            <div class="bottom-buttons">
              <button class="bottom-button" data-click="statut" id="button_status">Status</button>
              <button class="bottom-button" data-click="enregistrer" id="button_archive">Archive</button>
              <button class="bottom-button" data-click="partager" id="button_share">Share</button>
            </div>
          </div>

          <!-- Patient selection modal -->
          <div class="patient-select-container">
            <button class="select-button" id="patientSelectBtn" style="display:none;">
              <span>Select a patient</span>
              <span>â–¼</span>
            </button>
            <div class="modal" id="patientModal">
              <div class="modal-content">
                <button class="close-button" id="closePatientModalBtn">âœ•</button>
                <div class="modal-header">
                  <h3 class="modal-title" id="select_patient_title">Select a patient</h3>
                  <div class="search-container">
                    <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="11" cy="11" r="8"></circle>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <div id="patientSearchHolder">
                      <input type="text" class="search-input" placeholder="Search for a patient..." id="searchInput">
                    </div>
                  </div>
                </div>
                <button class="new-patient-btn" id="newPatientBtn">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <line x1="19" y1="8" x2="19" y2="14"></line>
                    <line x1="16" y1="11" x2="22" y2="11"></line>
                  </svg>
                  New patient
                </button>
                <div class="divider"></div>
                <div class="patients-list" id="patientsList">
                  <!-- Patient list inserted dynamically -->
                </div>
              </div>
            </div>
          </div>

          <!-- Template selection modal -->
          <div class="template-select-container">
            <div class="modal" id="templateModal">
              <div class="modal-content">
                <button class="close-button" id="closeTemplateModalBtn">âœ•</button>
                <div class="modal-header">
                  <h3 class="modal-title" id="select_template_title">Select a template</h3>
                  <div class="search-container">
                    <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="11" cy="11" r="8"></circle>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <input type="text" class="search-input" placeholder="Search for a template..." id="templateSearchInput">
                  </div>
                </div>
                <div class="templates-list" id="templatesList">
                  <!-- Template list inserted dynamically -->
                </div>
              </div>
            </div>
          </div>

          <!-- Banners for temporary messages -->
          <div id="bannerContainer"></div>

          <!-- External libraries for PDF -->
          <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
          <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

          <!-- Main script (JS) -->
          <script>
            // Define functions that Python might call directly OUTSIDE the initialization guard
            // These must be directly on window to ensure they can be called from Python

            // Function to get the selected value from a dropdown (used by Python backend)
            window.getDropdownSelectedValue = function(dropdownId) {
              const dropdown = document.getElementById(dropdownId);
              if (!dropdown) return "";

              // Special handling for template selection dropdown - return clean name without stars
              if (dropdownId === "templateSelectBtn" && dropdown.dataset.templateName) {
                return dropdown.dataset.templateName;
              }

              // Default behavior for other dropdowns like language
              const spanElem = dropdown.querySelector("span:first-child");
              if (!spanElem) return "";

              return spanElem.textContent.trim();
            };

            // Get editor content (used by Python backend)
            window.getEditorContent = function() {
              const editor = document.getElementById('editor');
              return editor ? editor.innerHTML : "";
            };

            // Set editor content (used by Python backend)
            window.setEditorContent = function(value) {
              const editor = document.getElementById('editor');
                if (editor) editor.innerHTML = value;
                };

                // Function to display banners (used by Python backend)
                window.displayBanner = function(message, type) {
                const bannerContainer = document.getElementById('bannerContainer');
                if (!bannerContainer) return;

                const banner = document.createElement('div');
                banner.className = 'banner ' + (type === 'success' ? 'banner-success' : 'banner-error');
                banner.textContent = message;
                bannerContainer.appendChild(banner);

                setTimeout(() => {
                banner.style.opacity = '0';
                setTimeout(() => {
                if (banner.parentNode) {
                banner.parentNode.removeChild(banner);
                }
                }, 300);
                }, 3000);
                };

                // Critical function that gets called by Python immediately
                window.rebuildPatientSearchInput = function() {
                console.log("[DEBUG JS] rebuildPatientSearchInput called");
                var searchHolder = document.getElementById("patientSearchHolder");
                if (searchHolder) {
                var newInput = document.createElement("input");
                newInput.type = "text";
                newInput.className = "search-input";
                newInput.id = "searchInput";
                newInput.placeholder = "Search for a patient...";

                newInput.addEventListener('input', function() {
                // Use a safe way to call searchPatientsInModal
                if (window.searchPatientsInModal) {
                window.searchPatientsInModal(this.value);
                } else {
                console.error("[DEBUG JS] searchPatientsInModal not available yet");
                // Try calling it directly without window
                try {
                searchPatientsInModal(this.value);
                } catch (e) {
                console.error("[DEBUG JS] Direct call also failed:", e);
                }
                }
                });

                searchHolder.innerHTML = "";
                searchHolder.appendChild(newInput);
                } else {
                console.error("[DEBUG JS] Could not find patientSearchHolder element");
                }
                };

                // Populate the template modal with templates data (used by Python backend)
                window.populateTemplateModal = function(templates) {
                templates = templates.filter(t => t.priority === 1 || t.priority === 2);
                templates.sort((a, b) => {
                if (a.priority === 2 && b.priority !== 2) return -1;
                if (b.priority === 2 && a.priority !== 2) return 1;
                return 0;
                });
                window.templatesData = templates;

                let defaultTemplate = templates.find(t => t.priority === 2);
                if (!defaultTemplate) { defaultTemplate = templates[0]; }

                if (defaultTemplate) {
                let starColor = defaultTemplate.priority === 2 ? "green" : "yellow";
                const templateButton = document.getElementById('templateSelectBtn');
                if (templateButton) {
                // Store the original template name as a data attribute
                templateButton.dataset.templateName = defaultTemplate.template_name;

                // Display the template name with star for visual indication
                const displaySpan = templateButton.querySelector('span:first-child');
                if (displaySpan) {
                displaySpan.innerHTML =
                defaultTemplate.template_name + ' <span class="star-icon" style="color:' + starColor + '">â˜…</span>';
                }
                }

                // Always clear the editor first
                window.setEditorContent('');

                // Then set content if applicable for this template
                if (defaultTemplate.display_template === true && defaultTemplate.text_to_display) {
                console.log("[DEBUG] Default template has display_template=true, updating editor content");
                window.setEditorContent(defaultTemplate.text_to_display);
                }

                // Store the selected template
                window.selectedTemplate = defaultTemplate;
                }

                // Use safe way to call renderTemplates
                if (window.renderTemplates) {
                window.renderTemplates(templates);
                } else {
                console.error("[DEBUG JS] renderTemplates not available yet when populateTemplateModal was called");
                }
                };

                // --------------------------------------------------------------------------------------------
                // GOLDEN RULE 1: Define Global Variables and Helper Functions Only Once
                // --------------------------------------------------------------------------------------------
                if (!window.__my_audio_manager_globals) {
                window.__my_audio_manager_globals = true;

                window.setElementText = function(elementId, newText) {
                const element = document.getElementById(elementId);
                if (element) {
                element.textContent = newText;
                }
                };

                window.setPlaceholderById = function(elementId, newText) {
                const element = document.getElementById(elementId);
                if (element) {
                element.placeholder = newText;
                }
                };

                // Global state for audio recording
                window.recordingState = {
                mediaRecorder: null,
                recordedChunks: [],
                audioBlob: null,
                stream: null,
                isRecording: false,
                isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
                recordRTC: null,
                uploadedFile: null,
                processingInProgress: false,
                wakeLock: null,
                noSleep: null
                };

                window.wakeLockController = {
                wakeLock: null,
                noSleep: null,

                init: function() {
                if (!this.noSleep) {
                this.noSleep = new NoSleep();
                }
                },

                requestWakeLock: function() {
                this.init();
                // Try Screen Wake Lock API first
                if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen')
                .then((lock) => {
                console.log('[DEBUG] Wake Lock activated with Screen Wake Lock API');
                this.wakeLock = lock;
                this.wakeLock.addEventListener('release', () => {
                console.log('[DEBUG] Wake Lock was released by the system');
                });
                })
                .catch((err) => {
                console.log('[DEBUG] Failed to activate Screen Wake Lock API, falling back to NoSleep.js:', err);
                this.noSleep.enable();
                });
                } else {
                console.log('[DEBUG] Screen Wake Lock API not supported, using NoSleep.js');
                this.noSleep.enable();
                }
                },

                releaseWakeLock: function() {
                if (this.wakeLock) {
                this.wakeLock.release()
                .then(() => {
                this.wakeLock = null;
                console.log('[DEBUG] Wake Lock released');
                })
                .catch(err => {
                console.log('[DEBUG] Error releasing wake lock:', err);
                });
                }
                if (this.noSleep) {
                this.noSleep.disable();
                }
                }
                };

                // Separate state for toolbar recording
                window.toolbarRecorder = {
                stream: null,
                mediaRecorder: null,
                isRecording: false,
                recordedChunks: [],
                bannerFlashInterval: null
                };

                // Make renderTemplates available on the window object
                window.renderTemplates = function(templatesToRender) {
                const templatesList = document.getElementById('templatesList');
                if (!templatesList) return;

                templatesList.innerHTML = '';

                if (!templatesToRender || templatesToRender.length === 0) {
                templatesList.innerHTML = '<div class="template-item">No templates found</div>';
                return;
                }

                templatesToRender.forEach(template => {
                let starColor = "gray";
                if (template.priority === 2) {
                starColor = "green";
                } else if (template.priority === 1) {
                starColor = "yellow";
                }

                const button = document.createElement('button');
                button.className = 'template-item';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = template.template_name;
                button.appendChild(nameSpan);

                const starSpan = document.createElement('span');
                starSpan.className = 'star-icon';
                starSpan.style.color = starColor;
                starSpan.textContent = 'â˜…';
                button.appendChild(starSpan);

                button.addEventListener('click', function() {
                // Pass the entire template object instead of just id/name/color
                window.selectTemplate(template);
                });

                templatesList.appendChild(button);
                });
                };

                // Make all helper functions that might be called from elsewhere available on the window
                window.openPatientModalForSave = function() {
                var modal = document.getElementById('patientModal');
                if (modal) modal.style.display = 'block';
                window.rebuildPatientSearchInput();
                window.searchPatientsInModal('');
                };

                window.closePatientModal = function() {
                var modal = document.getElementById('patientModal');
                if (modal) modal.style.display = 'none';
                };

                window.searchPatientsInModal = function(searchTerm) {
                var modal = document.getElementById('patientModal');
                anvil.call(modal, 'search_patients_relay', searchTerm)
                .then(function(patients) {
                window.renderPatients(patients);
                })
                .catch(function(error){
                console.error("Error searching for patients:", error);
                window.renderPatients([]);
                });
                };

                window.renderPatients = function(patients) {
                const patientsList = document.getElementById('patientsList');
                if (!patientsList) return;

                patientsList.innerHTML = '';

                patients.forEach(patient => {
                const button = document.createElement('button');
                button.className = 'patient-item';
                button.textContent = patient.name;
                button.addEventListener('click', function() {
                window.selectPatientForSave(patient.unique_id, patient.name);
                });
                patientsList.appendChild(button);
                });
                };

                window.selectPatientForSave = function(id, name) {
                window.selectedPatient = { unique_id: id, name: name };
                window.closePatientModal();
                window.continueSave();
                };

                window.newPatientForSave = function() {
                var modal = document.getElementById('patientModal');
                anvil.call(modal, 'get_new_patient_details')
                .then(function(newDetails){
                if(newDetails) {
                window.selectedPatient = { unique_id: null, name: newDetails.name, details: newDetails };
                window.closePatientModal();
                window.continueSave();
                }
                })
                .catch(function(error){
                console.error("Error getting new patient details:", error);
                });
                };

                window.continueSave = function() {
                var contentJSON = JSON.stringify({ content: window._saveContentData.content });
                var modal = document.getElementById('patientModal');
                anvil.call(modal, 'save_report', contentJSON, window._saveContentData.images, window.selectedPatient)
                .then(function(result){
                if(result) {
                window.displayBanner("Report saved successfully", "success");
                } else {
                alert("Failed to save report");
                }
                })
                .catch(function(error){
                console.error("Error saving report:", error);
                alert("Error: " + error.message);
                });
                };

                // Make available all functions that might be called from elsewhere
                window.openTemplateModal = function() {
                const templateModal = document.getElementById('templateModal');
                if (templateModal) templateModal.style.display = 'block';

                const templateSearchInput = document.getElementById('templateSearchInput');
                if (templateSearchInput) templateSearchInput.value = '';

                window.renderTemplates(window.templatesData || []);
                };

                window.closeTemplateModal = function() {
                const templateModal = document.getElementById('templateModal');
                if (templateModal) templateModal.style.display = 'none';
                };

                window.selectTemplate = function(template) {
                const id = template.id;
                const name = template.template_name;
                const starColor = template.starColor ||
                (template.priority === 2 ? "green" : template.priority === 1 ? "yellow" : "gray");

                const templateButton = document.getElementById('templateSelectBtn');
                if (templateButton) {
                // Store the clean template name as a data attribute
                templateButton.dataset.templateName = name;

                // Display with star for visual indication
                const displaySpan = templateButton.querySelector('span:first-child');
                if (displaySpan) {
                displaySpan.innerHTML =
                name + ' <span class="star-icon" style="color:' + starColor + '">â˜…</span>';
                }
                }

                // First, always clear the editor to ensure a clean state
                // This ensures we don't keep old content when switching templates
                window.setEditorContent('');

                // Then, only set new content if this template should display its content
                if (template.display_template === true && template.text_to_display) {
                console.log("[DEBUG] Template has display_template=true, updating editor content");
                window.setEditorContent(template.text_to_display);
                }

                // Update the stored selected template
                window.selectedTemplate = template;

                window.closeTemplateModal();
                };

                window.searchTemplatesInModal = function(searchTerm) {
                var modal = document.getElementById('templateModal');
                anvil.call(modal, 'search_template_relay', searchTerm)
                .then(function(templates) {
                window.renderTemplates(templates);
                })
                .catch(function(error){
                console.error("Error searching templates:", error);
                window.renderTemplates([]);
                });
                };

                // Set up iOS recorder with enhanced configuration
                window.initializeIOSRecording = function(state, event) {
                state.recordRTC = new RecordRTC(state.stream, {
                disableLogs: false,
                type: 'audio',
                mimeType: 'audio/wav',
                recorderType: RecordRTC.StereoAudioRecorder,
                bufferSize: 16384,
                sampleRate: 44100,
                numberOfAudioChannels: 1,
                timeSlice: 10000,
                checkForInactiveTracks: true,
                desiredSampRate: 44100
                });

                state.recordRTC.startRecording();
                state.isRecording = true;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
                <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                `;
                }

                // Notify backend
                anvil.call(event.target, "start_recording");
                window.startRecordingFlash();
                };

                // Helper functions for audio playback
                window.updateAudioProgress = function() {
                const audioPlayback = document.getElementById("audioPlayback");
                const audioProgressBar = document.getElementById("audioProgressBar");
                const audioDuration = document.getElementById("audioDuration");

                if (!audioPlayback || !audioPlayback.duration) return;

                const progress = (audioPlayback.currentTime / audioPlayback.duration) * 100;
                if (audioProgressBar) {
                audioProgressBar.style.width = `${progress}%`;
                }

                if (audioDuration) {
                audioDuration.textContent = `${window.formatTime(audioPlayback.currentTime)} / ${window.formatTime(audioPlayback.duration)}`;
                }
                };

                window.updateAudioDuration = function() {
                const audioPlayback = document.getElementById("audioPlayback");
                const audioDuration = document.getElementById("audioDuration");

                if (!audioPlayback || !audioPlayback.duration) return;

                if (audioDuration) {
                audioDuration.textContent = `0:00 / ${window.formatTime(audioPlayback.duration)}`;
                }
                };

                window.setupIOSSupport = function() {
                console.log("[DEBUG] Setting up iOS-specific enhancements");

                // Show iOS-specific instructions
                const iosInstructions = document.querySelector('.ios-instructions');
                if (iosInstructions) {
                iosInstructions.style.display = 'block';
                }

                // Ensure file input accepts iOS formats
                const audioFileInput = document.getElementById('audioFileInput');
                if (audioFileInput) {
                audioFileInput.setAttribute('accept', 'audio/*,.m4a,.caf,.aac,.mp4');
                }

                // Enhance button sizes for iOS
                const uploadButton = document.querySelector('.upload-button');
                if (uploadButton) {
                uploadButton.style.minHeight = '44px';
                uploadButton.style.fontSize = '16px';
                uploadButton.style.padding = '12px 20px';
                }

                // Add helpful alert for iOS users
                const dropZone = document.getElementById('dropZone');
                if (dropZone) {
                // Replace with a new one to clear any existing handlers
                const newDropZone = dropZone.cloneNode(true);
                dropZone.parentNode.replaceChild(newDropZone, dropZone);

                newDropZone.addEventListener('click', function(e) {
                // Don't interfere with clicks on buttons or inputs
                if (e.target.classList.contains('upload-button') || e.target.tagName === 'INPUT') {
                return;
                }

                // Show a helpful tip before opening the file selector
                if (confirm("Tip for iPhone: If you don't see your voice memos, try saving them to the Files app first.\\n\\nOpen file selector?")) {
                const audioFileInput = document.getElementById('audioFileInput');
                if (audioFileInput) audioFileInput.click();
                }
                });
                }
                };

                /* ---------- STOP-BUTTON UX ---------- */
                window.setStopButtonBusy = function (busy) {
                const stopBtn = document.getElementById('stopButton');
                if (!stopBtn) return;

                if (busy) {
                stopBtn.disabled = true;               // block double-taps
                stopBtn.dataset.prevHTML = stopBtn.innerHTML;  // keep the icon
                stopBtn.innerHTML = 'Stoppingâ€¦';       // quick textual feedback
                } else {
                stopBtn.disabled = false;
                if (stopBtn.dataset.prevHTML) {
                stopBtn.innerHTML = stopBtn.dataset.prevHTML;
                delete stopBtn.dataset.prevHTML;
                }
                }
                };


                // Update time display
                window.updateTime = function() {
                const now = new Date();
                const hrs = now.getHours().toString().padStart(2, '0');
                const mins = now.getMinutes().toString().padStart(2, '0');
                const timeElement = document.querySelector('.time');
                if (timeElement) {
                timeElement.textContent = `${hrs}:${mins}`;
                }
                };

                // Globally exposed methods
                window.blobToBase64 = function(blob) {
                return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                const resultStr = reader.result;
                const base64 = resultStr.split(',')[1];
                resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
                });
                };

                // Update progress ring UI
                window.setRingPercentage = function(percentage) {
                const ringElem = document.getElementById("progressRing");
                if (!ringElem) return;

                const clamped = Math.max(0, Math.min(100, percentage));
                const angle = (clamped / 100) * 360;
                ringElem.style.background = `conic-gradient(#4caf50 ${angle}deg, #ddd ${angle}deg)`;
                };

                // Visual feedback for recording state
                window.startRecordingFlash = function() {
                const ringElem = document.getElementById("progressRing");
                if (ringElem) {
                ringElem.classList.add("recording-flash");
                }
                };

                window.stopRecordingFlash = function() {
                window.setStopButtonBusy(true);
                const ringElem = document.getElementById("progressRing");
                if (ringElem) {
                ringElem.classList.remove("recording-flash");
                }
                };

                // Simulate progress for transcription process
                window.simulateTranscriptionProgress = function() {
                window.transcriptionProgress = {
                currentProgress: 0,
                intervalId: null
                };

                window.setRingPercentage(0);
                window.transcriptionProgress.intervalId = setInterval(() => {
                if (window.transcriptionProgress.currentProgress < 90) {
                window.transcriptionProgress.currentProgress += 1;
                window.setRingPercentage(window.transcriptionProgress.currentProgress);
                } else {
                clearInterval(window.transcriptionProgress.intervalId);
                }
                }, 400);
                };

                window.finishTranscriptionProgress = function() {
                if (window.transcriptionProgress && window.transcriptionProgress.intervalId) {
                clearInterval(window.transcriptionProgress.intervalId);
                }
                window.setRingPercentage(100);
                };

                // Mobile audio display update
                window.updateMobileAudioDisplay = function() {
                var display = document.getElementById("mobileAudioDisplay");
                if (!display) return;

                if (window.recordingState.audioBlob) {
                display.innerHTML = "Audio ðŸŽµ <button id='mobileClearButton' onclick='clearRecording(event)'>ðŸ—‘</button>";

                // Add event listener to the newly created button
                const mobileClearButton = document.getElementById("mobileClearButton");
                if (mobileClearButton) {
                mobileClearButton.addEventListener("click", function(e) {
                e.preventDefault();
                e.stopPropagation();
                window.clearRecording(e);
                });
                }
                } else {
                display.innerHTML = "";
                }
                };

                // Recording functions
                window.startRecording = async function(event) {
                const state = window.recordingState;

                // Prevent multiple recording sessions
                if (state.isRecording) {
                console.log('[DEBUG] Recording already in progress');
                return;
                }

                // Request wake lock to keep screen on
                window.wakeLockController.requestWakeLock();

                try {
                // Request microphone access
                state.stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                if (state.isIOS) {
                // iOS-specific implementation with RecordRTC
                console.log('[DEBUG] Starting iOS recording with RecordRTC');

                if (typeof RecordRTC === 'undefined') {
                // Load RecordRTC if not already loaded
                const script = document.createElement('script');
                script.src = 'https://www.webrtc-experiment.com/RecordRTC.js';
                script.onload = function() {
                window.initializeIOSRecording(state, event);
                };
                document.head.appendChild(script);
                } else {
                window.initializeIOSRecording(state, event);
                }
                } else {
                // Standard WebRTC implementation
                console.log('[DEBUG] Starting standard recording with MediaRecorder');

                state.mediaRecorder = new MediaRecorder(state.stream);
                state.recordedChunks = [];

                state.mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) {
                state.recordedChunks.push(e.data);
                }
                };

                state.mediaRecorder.start();
                state.isRecording = true;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
                <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                `;
                }

                // Notify backend
                anvil.call(event.target, "start_recording");
                window.startRecordingFlash();
                }
                } catch (err) {
                console.error('[DEBUG] Error accessing microphone:', err);
                alert("Unable to access microphone. Please check permissions.");

                // Release wake lock if we couldn't start recording
                window.wakeLockController.releaseWakeLock();
                }
                };

                // Pause recording
                window.pauseRecording = function(event) {
                const state = window.recordingState;

                if (!state.isRecording) {
                console.log('[DEBUG] No recording to pause');
                return;
                }

                if (state.isIOS) {
                if (state.recordRTC) {
                console.log('[DEBUG] Pausing iOS recording');
                state.recordRTC.pauseRecording();
                state.isRecording = false;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                </svg>
                `;
                }

                // Notify backend
                anvil.call(event.target, "pause_recording");
                }
                } else {
                if (state.mediaRecorder && state.mediaRecorder.state === "recording") {
                console.log('[DEBUG] Pausing standard recording');
                state.mediaRecorder.pause();
                state.isRecording = false;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                </svg>
                `;
                }

                // Notify backend
                anvil.call(event.target, "pause_recording");
                }
                }
                };

                // Resume recording
                window.resumeRecording = function(event) {
                const state = window.recordingState;

                if (state.isRecording) {
                console.log('[DEBUG] Recording already active');
                return;
                }

                if (state.isIOS) {
                if (state.recordRTC) {
                console.log('[DEBUG] Resuming iOS recording');
                state.recordRTC.resumeRecording();
                state.isRecording = true;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
                <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                `;
                }

                // Notify backend
                anvil.call(event.target, "start_recording");
                }
                } else {
                if (state.mediaRecorder && state.mediaRecorder.state === "paused") {
                console.log('[DEBUG] Resuming standard recording');
                state.mediaRecorder.resume();
                state.isRecording = true;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                <rect x="9" y="2" width="6" height="12" rx="3" fill="currentColor"/>
                <path d="M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                `;
                }

                // Notify backend
                anvil.call(event.target, "start_recording");
                }
                }
                };

                // Stop and process recording
                window.stopRecording = function(event) {
                const state = window.recordingState;

                if (state.processingInProgress) {
                console.log('[DEBUG] Processing already in progress, cannot stop');
                return;
                }

                state.processingInProgress = true;

                if (state.isIOS) {
                if (state.recordRTC) {
                console.log('[DEBUG] Stopping iOS recording');

                state.recordRTC.stopRecording(function() {
                const blob = state.recordRTC.getBlob();
                state.audioBlob = blob;
                window.lastAudioBlob = blob;

                // Set up audio playback
                const audioPlayback = document.getElementById("audioPlayback");
                if (audioPlayback) {
                const audioURL = URL.createObjectURL(blob);
                audioPlayback.src = audioURL;
                audioPlayback.load();
                }

                // Process the recording
                window.processRecordedAudio(blob, event);

                // Notify backend
                anvil.call(event.target, "stop_recording");
                window.stopRecordingFlash();

                // Clean up resources
                state.recordRTC.destroy();
                if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
                }

                setTimeout(() => {
                state.recordRTC = null;
                state.stream = null;
                }, 300);
                });

                state.isRecording = false;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                </svg>
                `;
                }
                }
                } else {
                if (state.mediaRecorder && state.mediaRecorder.state !== "inactive") {
                console.log('[DEBUG] Stopping standard recording');

                state.mediaRecorder.onstop = () => {
                const blob = new Blob(state.recordedChunks, { type: 'audio/webm' });
                state.audioBlob = blob;
                window.lastAudioBlob = blob;

                // Set up audio playback
                const audioPlayback = document.getElementById("audioPlayback");
                if (audioPlayback) {
                const audioURL = URL.createObjectURL(blob);
                audioPlayback.src = audioURL;
                audioPlayback.load();
                }

                // Process the recording
                window.processRecordedAudio(blob, event);

                // Notify backend
                anvil.call(event.target, "stop_recording");
                window.stopRecordingFlash();
                };

                state.mediaRecorder.stop();
                state.isRecording = false;

                // Update UI
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                </svg>
                `;
                }
                }
                }

                // Release wake lock after recording
                window.wakeLockController.releaseWakeLock();
                };

                /* ------------------------------------------------------------------
                Recording upload â€“ â€œno-chunkâ€ version
                ------------------------------------------------------------------ */

                /* Helper: convert a Blob to base-64 (kept for very small files) */
                window.blobToBase64 = async function (blob) {
                return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]); // drop data URL header
                reader.onerror  = reject;
                reader.readAsDataURL(blob);
                });
                };

                /* --------------------------------------------------------------
                Main entry: send audio, either as base-64 (< 500 kB) or Media
                -------------------------------------------------------------- */

                /* ------------------------------------------------------------------
                Cut blob into binary chunks
                ------------------------------------------------------------------ */
                window.chunkBlob = async function (blob, chunkSize) {
                const out = [];
                for (let start = 0; start < blob.size; start += chunkSize) {
                out.push(blob.slice(start, Math.min(start + chunkSize, blob.size)));
                }
                return out;
                };

                /* ------------------------------------------------------------------
                Send recording â€“ <500 kB direct / â‰¥500 kB chunks base-64
                ------------------------------------------------------------------ */
                window.processRecordedAudio = async function (blob, event) {

                const SMALL_FILE_LIMIT = 500 * 1024;    // 500 kB
                const CHUNK_SIZE       = 400 * 1024;    // 400 kB (before encoding)

                try {
                console.log('[DEBUG] Processing recorded audio');
                window.simulateTranscriptionProgress();

                /*// -------- 1.  SMALL files (< 500 kB) keep the old animation -------- */
                if (blob.size < SMALL_FILE_LIMIT) {
                const b64 = await window.blobToBase64(blob);
                return anvil.call(event.target, 'process_recording', b64)
                .then(handleSuccess)
                .catch(handleError);
                }

                /* -------- 2. Large files: cut + send chunk by chunk -------- */
                window.setRingPercentage(0);                   // reset once
                const chunks = await window.chunkBlob(blob, CHUNK_SIZE);
                console.log(`[DEBUG] Cut into ${chunks.length} chunks`);

                for (let i = 0; i < chunks.length; i++) {
                const b64Chunk = await window.blobToBase64(chunks[i]);
                await anvil.call(event.target, 'receive_audio_chunk', b64Chunk, i, chunks.length);


                /* progress grows from 0 â†’ 90 % as chunks are sent */
                const pct = Math.round(((i + 1) / chunks.length) * 90);
                window.setRingPercentage(pct);
                }

                console.log('[DEBUG] All chunks sent â€“ consolidation on Python side');
                return anvil.call(event.target, 'process_consolidated_audio')
                .then(handleSuccess)
                .catch(handleError);

                } catch (err) {
                handleError(err);
                }

                /* ---------------- helpers ---------------- */
                function handleSuccess(result) {
                if (result && typeof result === 'object' && result.error) {
                alert(result.error);
                console.warn(result);
                } else {
                console.log('[DEBUG] Audio processing complete', result);
                }
                window.finishTranscriptionProgress();
                document.getElementById('retryProcessBtn').style.display = 'block';
                window.recordingState.processingInProgress = false;
                window.setStopButtonBusy(false);
                return result;
                }

                function handleError(err) {
                console.error('[DEBUG] Error processing recording', err);
                alert('Detailed error: ' + (err?.message || err));
                window.finishTranscriptionProgress();
                window.recordingState.processingInProgress = false;
                }
                };




                // Start the separate toolbar recorder
                window.startToolbarRecording = function(event) {
                console.log("[DEBUG] Starting separate toolbar recorder...");

                if (window.toolbarRecorder.isRecording) {
                alert("A toolbar recording is already in progress.");
                return;
                }

                window.wakeLockController.requestWakeLock();

                navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                window.toolbarRecorder.stream = stream;
                window.toolbarRecorder.mediaRecorder = new MediaRecorder(stream);
                window.toolbarRecorder.recordedChunks = [];

                window.toolbarRecorder.mediaRecorder.ondataavailable = evt => {
                if (evt.data.size > 0) {
                window.toolbarRecorder.recordedChunks.push(evt.data);
                }
                };

                window.toolbarRecorder.mediaRecorder.start();
                window.toolbarRecorder.isRecording = true;

                // Add visual flash to the microphone icon button
                let startBtn = document.getElementById('startToolbarRecBtn');
                if (startBtn) {
                startBtn.classList.add("tb-recording-flash");
                }

                // Show the red flashing banner
                window.startToolbarRecordingBanner();
                })
                .catch(err => {
                console.error("[DEBUG] Error accessing microphone for toolbar:", err);
                alert("Failed to access microphone (toolbar).");
                });
                };

                // Finalize toolbar recording
                window.finalizeToolbarRecording = function() {
                return new Promise((resolve, reject) => {
                if (!window.toolbarRecorder || !window.toolbarRecorder.isRecording) {
                // No recording to finalize
                resolve();
                return;
                }

                console.log("[DEBUG] Stopping toolbar recorder...");

                // Remove the highlight on the mic icon button
                let startBtn = document.getElementById('startToolbarRecBtn');
                if (startBtn) {
                startBtn.classList.remove("tb-recording-flash");
                }

                // Stop the flashing banner
                window.stopToolbarRecordingBanner();

                window.toolbarRecorder.mediaRecorder.onstop = function() {
                console.log("[DEBUG] MediaRecorder (toolbar) stopped. Finalizing blob...");
                let blob = new Blob(window.toolbarRecorder.recordedChunks, { type: 'audio/webm' });

                window.processToolbarRecordingBlob(blob)
                .then(() => {
                resolve();
                })
                .catch(err => {
                console.error("[DEBUG] Error processing toolbar recording:", err);
                reject(err);
                });
                };

                window.toolbarRecorder.mediaRecorder.stop();
                window.toolbarRecorder.isRecording = false;

                // Clean up resources
                window.toolbarRecorder.stream.getTracks().forEach(track => track.stop());
                });
                };

                // Process toolbar recording
                window.processToolbarRecordingBlob = async function(blob) {
                console.log("[DEBUG] Converting toolbar blob to base64...");

                try {
                // Convert to base64
                let base64Audio = await window.blobToBase64(blob);

                // Send to Python backend
                const anchor = document.getElementById("toolbarRecorderAnchor");
                let resp = await anvil.call(anchor, "process_toolbar_recording", base64Audio);

                console.log("[DEBUG] Toolbar snippet processed. Response:", resp);
                return resp;
                } catch (err) {
                console.error("[DEBUG] Error converting toolbar blob:", err);
                alert("Error converting BLOB (toolbar).");
                throw err;
                }
                };

                // Handle toolbar recording banner
                window.startToolbarRecordingBanner = function() {
                const container = document.getElementById('bannerContainer');
                if (!container) return;

                // Avoid duplicates
                let existing = document.getElementById('toolbarRecordingBanner');
                if (existing) return;

                let banner = document.createElement('div');
                banner.id = 'toolbarRecordingBanner';
                banner.classList.add('banner-flash');
                banner.textContent = "Recording in progress...";
                container.appendChild(banner);

                // Repeatedly toggle .flash-state for the blink effect
                window.toolbarRecorder.bannerFlashInterval = setInterval(() => {
                banner.classList.toggle('flash-state');
                }, 1000);
                };

                window.stopToolbarRecordingBanner = function() {
                let banner = document.getElementById('toolbarRecordingBanner');
                if (banner && banner.parentNode) {
                banner.parentNode.removeChild(banner);
                }

                if (window.toolbarRecorder && window.toolbarRecorder.bannerFlashInterval) {
                clearInterval(window.toolbarRecorder.bannerFlashInterval);
                window.toolbarRecorder.bannerFlashInterval = null;
                }
                };

                // Process uploaded audio file
                window.processUploadedFile = function(event) {
                const state = window.recordingState;

                if (!state.uploadedFile) {
                alert("Please select an audio file first.");
                return;
                }

                if (state.processingInProgress) {
                console.log('[DEBUG] Processing already in progress');
                return;
                }

                state.processingInProgress = true;

                // --- CHANGEMENT 1 : BASCULER LA VUE ET DÃ‰MARRER L'ANIMATION ---\
                // Cacher la section d'upload et montrer l'anneau de progression. C'est correct.\
                window.toggleMode('record');
                window.simulateTranscriptionProgress();
                // -----------------------------------------------------------\

                const reader = new FileReader();
                reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                const blob = new Blob([arrayBuffer], { type: state.uploadedFile.type });

                window.blobToBase64(blob)
                .then(base64Audio => {
                // --- CORRECTION CLÃ‰ : UTILISER UNE ANCRE STABLE ---\
                // Au lieu de fileInput, nous utilisons un Ã©lÃ©ment qui n'est jamais cachÃ©.\
                const anchor = document.getElementById('toolbarRecorderAnchor');
                if (!anchor) {
                console.error("CRITICAL: toolbarRecorderAnchor element not found!");
                alert("Interface error, please reload.");

                // RÃ©initialiser en cas d'erreur critique\
                window.setRingPercentage(0);
                window.toggleMode('upload');
                state.processingInProgress = false;
                return;
                }
                // ----------------------------------------------------\

                // Appel au serveur (la fonction process_uploaded_audio appelle process_recording)\
                return anvil.call(anchor, "process_uploaded_audio", base64Audio) // Utilisation de 'anchor' ici\
                .then(result => {
                console.log("[DEBUG] Audio file processed. Server response:", result);

                // --- CHANGEMENT 2 : TERMINER L'ANIMATION EN CAS DE SUCCÃˆS ---\
                window.finishTranscriptionProgress();
                // -----------------------------------------------------------\

                // Stocker le blob pour une Ã©ventuelle relecture ou un nouvel essai\
                state.audioBlob = blob;
                window.lastAudioBlob = blob;

                // Configurer la lecture audio\
                const audioPlayback = document.getElementById("audioPlayback");
                if (audioPlayback) {
                const audioURL = URL.createObjectURL(blob);
                audioPlayback.src = audioURL;
                audioPlayback.load();
                }

                // Afficher le bouton "Retry"\
                document.getElementById("retryProcessBtn").style.display = "block";

                window.updateMobileAudioDisplay();
                state.processingInProgress = false;
                })
                .catch(error => {
                console.error("[DEBUG] Error processing audio file:", error);
                alert("An error occurred while processing the audio file.");

                // --- CHANGEMENT 3 : GÃ‰RER L'Ã‰CHEC ---\
                window.setRingPercentage(0); // RÃ©initialiser l'anneau\
                window.toggleMode('upload');   // Revenir Ã  l'Ã©cran d'upload\
                // ------------------------------------\

                state.processingInProgress = false;
                });
                })
                .catch(err => {
                console.error("[DEBUG] Error converting file:", err);
                alert("An error occurred while preparing the audio file.");
                window.setRingPercentage(0);
                window.toggleMode('upload');
                state.processingInProgress = false;
                });
                };

                reader.onerror = function() {
                console.error("[DEBUG] Error reading file:", reader.error);
                alert("An error occurred while reading the audio file.");
                window.setRingPercentage(0);
                window.toggleMode('upload');
                state.processingInProgress = false;
                };

                reader.readAsArrayBuffer(state.uploadedFile);
                };

                // Handle file selection
                window.handleFileSelect = function(event) {
                event.preventDefault();
                event.stopPropagation();

                // Get file from input or drop event
                let files;
                if (event.dataTransfer) {
                files = event.dataTransfer.files; // From drag & drop
                } else {
                files = event.target.files; // From file input
                }

                if (!files || files.length === 0) {
                console.log("[DEBUG] No files selected");
                return;
                }

                const file = files[0];

                // Check if it's an audio file
                if (!file.type.match('audio.*') && !file.name.match(/\\.(m4a|caf|mp3|aac|wav)$/i)) {
                alert('Please select an audio file.');
                return;
                }

                // Store file in global state
                window.recordingState.uploadedFile = file;

                // Update UI
                const fileName = document.getElementById('fileName');
                const fileSize = document.getElementById('fileSize');
                const fileInfo = document.getElementById('fileInfo');
                const formatWarning = document.getElementById('formatWarning');

                if (fileName) fileName.textContent = file.name;
                if (fileSize) fileSize.textContent = window.formatFileSize(file.size);
                if (fileInfo) fileInfo.style.display = 'block';

                // Check format compatibility with iOS
                const fileExtension = file.name.split('.').pop().toLowerCase();
                if (formatWarning) {
                if (['m4a', 'mp3', 'aac'].includes(fileExtension)) {
                formatWarning.style.display = 'none';
                } else {
                formatWarning.style.display = 'block';
                }
                }

                console.log(`[DEBUG] File selected: ${file.name} (${window.formatFileSize(file.size)})`);
                };

                // Format file size for display
                window.formatFileSize = function(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                };

                // Format time for audio display
                window.formatTime = function(seconds) {
                if (isNaN(seconds) || !isFinite(seconds)) return "0:00";
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
                };

                // Clear recording state
                window.clearRecording = function(event) {
                const state = window.recordingState;

                state.audioBlob = null;
                state.recordedChunks = [];
                state.uploadedFile = null;
                window.lastAudioBlob = null;

                // Handle iOS-specific cleanup
                if (state.isIOS) {
                if (state.recordRTC) {
                try {
                state.recordRTC.stopRecording(function() {
                state.recordRTC.destroy();
                if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
                }
                setTimeout(() => {
                state.recordRTC = null;
                state.stream = null;
                }, 300);
                });
                } catch (e) {
                console.log("[DEBUG] Error stopping RecordRTC:", e);
                }
                state.recordRTC = null;
                }
                } else {
                // Standard cleanup
                if (state.mediaRecorder && state.mediaRecorder.state !== "inactive") {
                try {
                state.mediaRecorder.stop();
                } catch (e) {
                console.log("[DEBUG] Error stopping mediaRecorder:", e);
                }
                }
                state.mediaRecorder = null;
                }

                // Stop any active tracks
                if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
                state.stream = null;
                }

                state.isRecording = false;

                // Reset UI elements
                const audioPlayback = document.getElementById("audioPlayback");
                if (audioPlayback) { audioPlayback.src = ""; }

                const audioProgressBar = document.getElementById("audioProgressBar");
                if (audioProgressBar) { audioProgressBar.style.width = "0%"; }

                const audioDuration = document.getElementById("audioDuration");
                if (audioDuration) { audioDuration.textContent = "0:00 / 0:00"; }

                window.stopRecordingFlash();
                window.setRingPercentage(0);

                const pb = document.getElementById("playButton");
                if (pb) {
                pb.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z"/>
                <path d="M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z"/>
                <path d="M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z"/>
                </svg>
                `;
                }

                document.getElementById("retryProcessBtn").style.display = "none";

                // Reset upload UI
                const fileInfo = document.getElementById("fileInfo");
                if (fileInfo) fileInfo.style.display = "none";

                const formatWarning = document.getElementById("formatWarning");
                if (formatWarning) formatWarning.style.display = "none";

                const audioFileInput = document.getElementById("audioFileInput");
                if (audioFileInput) audioFileInput.value = '';

                // Update mobile UI if needed
                window.updateMobileAudioDisplay();

                console.log("[DEBUG] Recording cleared");
                };

                // Format document (Bold, Italic, etc.)
                window.formatDoc = function(cmd) {
                document.execCommand(cmd, false, null);
                };

                // Insert image in editor
                window.insertImage = function() {
                var input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = function(e) {
                var file = e.target.files[0];
                var reader = new FileReader();
                reader.onload = function(event) {
                var img = document.createElement('img');
                img.src = event.target.result;
                img.style.maxWidth = '100%';
                img.dataset.referenceId = 'img_' + Date.now();
                document.getElementById('editor').appendChild(img);
                };
                reader.readAsDataURL(file);
                };
                input.click();
                };

                // Copy editor content
                window.copyEditorContent = function() {
                const editor = document.getElementById('editor');
                if (!editor) return;

                const range = document.createRange();
                range.selectNodeContents(editor);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                try {
                document.execCommand('copy');
                window.displayBanner('Content copied!', 'success');
                } catch (err) {
                console.error('Error copying content', err);
                }

                selection.removeAllRanges();
                };

                // Toggle between recording and upload modes
                window.toggleMode = function(mode) {
                const recordingMode = document.getElementById('recordingMode');
                const uploadMode = document.getElementById('uploadMode');
                const recordButton = document.getElementById('recordButton');
                const uploadButton = document.getElementById('uploadButton');

                if (mode === 'record') {
                if (recordingMode) recordingMode.style.display = 'block';
                if (uploadMode) uploadMode.style.display = 'none';
                if (recordButton) recordButton.classList.add('active');
                if (uploadButton) uploadButton.classList.remove('active');
                } else if (mode === 'upload') {
                if (recordingMode) recordingMode.style.display = 'none';
                if (uploadMode) uploadMode.style.display = 'block';
                if (recordButton) recordButton.classList.remove('active');
                if (uploadButton) uploadButton.classList.add('active');
                }
                };

                window.saveContent = function(event) {
                window._saveContentData = {
                content: document.getElementById('editor').innerHTML,
                images: Array.from(document.querySelectorAll('#editor img')).map(img => ({
                media: img.src,
                reference_id: img.dataset.referenceId || ('img_' + Date.now()),
                position: img.offsetTop.toString()
                }))
                };
                window.openPatientModalForSave();
                };

                // --------------------------------------------------------------------------------------------
                // GOLDEN RULE 2: Always Attach Event Listeners on Load
                // --------------------------------------------------------------------------------------------

                window.__attachAudioManagerEvents = function() {
                console.log("[DEBUG] ATTACHING AUDIO MANAGER EVENTS (FINAL ROBUST VERSION)");

                // ===================================
                // Section 1 : Main recording controls
                // ===================================
                const playButton = document.getElementById("playButton");
                if (playButton) {
                playButton.replaceWith(playButton.cloneNode(true));
                document.getElementById("playButton").addEventListener("click", function(event) {
                if (window.recordingState.isRecording) { window.pauseRecording(event); }
                else {
                if (window.recordingState.mediaRecorder && window.recordingState.mediaRecorder.state === "paused") { window.resumeRecording(event); }
                else { window.startRecording(event); }
                }
                });
                }

                const stopButton = document.getElementById("stopButton");
                if (stopButton) {
                stopButton.replaceWith(stopButton.cloneNode(true));
                document.getElementById("stopButton").addEventListener("click", function(event) {
                window.stopRecording(event);
                });
                }

                // ===================================
                // Section 2 : Mode toggle and file upload
                // ===================================
                const recordToggleBtn = document.getElementById("recordButton");
                if (recordToggleBtn) {
                recordToggleBtn.replaceWith(recordToggleBtn.cloneNode(true));
                document.getElementById("recordButton").addEventListener('click', () => window.toggleMode('record'));
                }

                const uploadToggleBtn = document.getElementById("uploadButton");
                if (uploadToggleBtn) {
                uploadToggleBtn.replaceWith(uploadToggleBtn.cloneNode(true));
                document.getElementById("uploadButton").addEventListener('click', () => window.toggleMode('upload'));
                }

                // ----------------------------------------------------
                // FIXED UPLOAD LOGIC
                // ----------------------------------------------------
                const dropZone = document.getElementById("dropZone");
                if (dropZone) {
                // Clone the entire drop zone. This clears all old listeners from the container and its children.
                const newDropZone = dropZone.cloneNode(true);
                dropZone.parentNode.replaceChild(newDropZone, dropZone);

                // Re-attach listeners for drag-and-drop functionality to the new element.
                newDropZone.addEventListener('dragover', e => { e.preventDefault(); e.stopPropagation(); newDropZone.classList.add('dragover'); });
                newDropZone.addEventListener('dragleave', e => { e.preventDefault(); e.stopPropagation(); newDropZone.classList.remove('dragover'); });
                newDropZone.addEventListener('drop', e => {
                e.preventDefault();
                e.stopPropagation();
                newDropZone.classList.remove('dragover');
                window.handleFileSelect(e); // This handles the dropped file.
                });

                // Re-attach the listener for clicks on the container, which triggers the file input.
                newDropZone.addEventListener('click', function(event) {
                // If the user clicks the actual button/label, let the default behavior happen.
                if (event.target.tagName === 'LABEL' || event.target.closest('label.upload-button')) {
                return;
                }
                // Otherwise, programmatically trigger the file input that is *inside* the new container.
                const fileInput = newDropZone.querySelector('#audioFileInput');
                if (fileInput) fileInput.click();
                });

                // THE CRITICAL FIX: Find the file input *inside our new cloned zone* and attach the 'change' listener.
                // This event fires when a user selects a file from the iOS file picker.
                const audioFileInput = newDropZone.querySelector("#audioFileInput");
                if (audioFileInput) {
                audioFileInput.addEventListener('change', function(event) {
                console.log("File selected via input. Calling handleFileSelect...");
                window.handleFileSelect(event);
                });
                }
                }

                // B. Handle the "Process" and "Remove" buttons (this logic can remain the same as they are outside the dropZone)
                const processFileButton = document.getElementById("processFileButton");
                if (processFileButton) {
                processFileButton.replaceWith(processFileButton.cloneNode(true));
                document.getElementById("processFileButton").addEventListener('click', window.processUploadedFile);
                }

                const removeFileButton = document.getElementById("removeFileButton");
                if (removeFileButton) {
                removeFileButton.replaceWith(removeFileButton.cloneNode(true));
                document.getElementById("removeFileButton").addEventListener('click', window.clearRecording);
                }

                // Editor toolbar buttons
                const boldBtn = document.getElementById("boldBtn");
                const italicBtn = document.getElementById("italicBtn");
                const underlineBtn = document.getElementById("underlineBtn");
                const leftAlignBtn = document.getElementById("leftAlignBtn");
                const centerAlignBtn = document.getElementById("centerAlignBtn");
                const rightAlignBtn = document.getElementById("rightAlignBtn");
                const insertImageBtn = document.getElementById("insertImageBtn");
                const copyBtn = document.getElementById("copyBtn");

                if (boldBtn) {
                boldBtn.replaceWith(boldBtn.cloneNode(true));
                const newBoldBtn = document.getElementById("boldBtn");
                newBoldBtn.addEventListener('click', function() {
                window.formatDoc('bold');
                });
                }

                if (italicBtn) {
                italicBtn.replaceWith(italicBtn.cloneNode(true));
                const newItalicBtn = document.getElementById("italicBtn");
                newItalicBtn.addEventListener('click', function() {
                window.formatDoc('italic');
                });
                }

                if (underlineBtn) {
                underlineBtn.replaceWith(underlineBtn.cloneNode(true));
                const newUnderlineBtn = document.getElementById("underlineBtn");
                newUnderlineBtn.addEventListener('click', function() {
                window.formatDoc('underline');
                });
                }

                if (leftAlignBtn) {
                leftAlignBtn.replaceWith(leftAlignBtn.cloneNode(true));
                const newLeftAlignBtn = document.getElementById("leftAlignBtn");
                newLeftAlignBtn.addEventListener('click', function() {
                window.formatDoc('justifyleft');
                });
                }

                if (centerAlignBtn) {
                centerAlignBtn.replaceWith(centerAlignBtn.cloneNode(true));
                const newCenterAlignBtn = document.getElementById("centerAlignBtn");
                newCenterAlignBtn.addEventListener('click', function() {
                window.formatDoc('justifycenter');
                });
                }

                if (rightAlignBtn) {
                rightAlignBtn.replaceWith(rightAlignBtn.cloneNode(true));
                const newRightAlignBtn = document.getElementById("rightAlignBtn");
                newRightAlignBtn.addEventListener('click', function() {
                window.formatDoc('justifyright');
                });
                }

                if (insertImageBtn) {
                insertImageBtn.replaceWith(insertImageBtn.cloneNode(true));
                const newInsertImageBtn = document.getElementById("insertImageBtn");
                newInsertImageBtn.addEventListener('click', function() {
                window.insertImage();
                });
                }

                if (copyBtn) {
                copyBtn.replaceWith(copyBtn.cloneNode(true));
                const newCopyBtn = document.getElementById("copyBtn");
                newCopyBtn.addEventListener('click', function() {
                window.copyEditorContent();
                });
                }

                // Toolbar recording related buttons
                const startToolbarRecBtn = document.getElementById('startToolbarRecBtn');
                if (startToolbarRecBtn) {
                startToolbarRecBtn.replaceWith(startToolbarRecBtn.cloneNode(true));
                const newToolbarRecButton = document.getElementById('startToolbarRecBtn');

                newToolbarRecButton.addEventListener('click', function(event) {
                window.startToolbarRecording(event);
                });
                }

                // Validate button
                const validateBtn = document.getElementById("validateBtn");
                if (validateBtn) {
                validateBtn.replaceWith(validateBtn.cloneNode(true));
                const newValidateButton = document.getElementById("validateBtn");

                newValidateButton.addEventListener('click', function(event) {
                // The validate button also finalizes any ongoing toolbar recording
                newValidateButton.classList.add("tb-processing-flash");

                // If a toolbar recording is in progress, finalize it first
                window.finalizeToolbarRecording()
                .then(() => {
                // Then call the normal validation server method
                return anvil.call(event.target, "validate_and_send");
                })
                .then(() => {
                // Once done, remove the processing flash
                newValidateButton.classList.remove("tb-processing-flash");
                })
                .catch((err) => {
                console.error("[DEBUG] Error finalizing or validating:", err);
                newValidateButton.classList.remove("tb-processing-flash");
                });
                });
                }

                // Template selection
                const templateSelectBtn = document.getElementById("templateSelectBtn");
                if (templateSelectBtn) {
                templateSelectBtn.replaceWith(templateSelectBtn.cloneNode(true));
                const newTemplateSelectBtn = document.getElementById("templateSelectBtn");

                newTemplateSelectBtn.addEventListener("click", function() {
                window.openTemplateModal();
                });
                }

                // Template search
                const templateSearchInput = document.getElementById("templateSearchInput");
                if (templateSearchInput) {
                templateSearchInput.replaceWith(templateSearchInput.cloneNode(true));
                const newTemplateSearchInput = document.getElementById("templateSearchInput");

                newTemplateSearchInput.addEventListener('input', function(event) {
                window.searchTemplatesInModal(event.target.value);
                });
                }

                // Template modal close button
                const closeTemplateModalBtn = document.getElementById("closeTemplateModalBtn");
                if (closeTemplateModalBtn) {
                closeTemplateModalBtn.replaceWith(closeTemplateModalBtn.cloneNode(true));
                const newCloseTemplateBtn = document.getElementById("closeTemplateModalBtn");

                newCloseTemplateBtn.addEventListener('click', function() {
                window.closeTemplateModal();
                });
                }

                // Patient modal buttons
                const closePatientModalBtn = document.getElementById("closePatientModalBtn");
                if (closePatientModalBtn) {
                closePatientModalBtn.replaceWith(closePatientModalBtn.cloneNode(true));
                const newClosePatientBtn = document.getElementById("closePatientModalBtn");

                newClosePatientBtn.addEventListener('click', function() {
                window.closePatientModal();
                });
                }

                const newPatientBtn = document.getElementById("newPatientBtn");
                if (newPatientBtn) {
                newPatientBtn.replaceWith(newPatientBtn.cloneNode(true));
                const newNewPatientBtn = document.getElementById("newPatientBtn");

                newNewPatientBtn.addEventListener('click', function() {
                window.newPatientForSave();
                });
                }

                // Language dropdown
                const allDropdowns = document.querySelectorAll('.dropdown');
                allDropdowns.forEach(dd => {
                // Remove existing handlers
                const newDD = dd.cloneNode(true);
                dd.parentNode.replaceChild(newDD, dd);

                newDD.addEventListener('click', function(e) {
                const menu = newDD.querySelector('.dropdown-menu');
                if (!menu || e.target.closest('.dropdown-menu')) return;

                menu.classList.toggle('active');
                });

                const dropdownItems = newDD.querySelectorAll('.dropdown-menu div');
                dropdownItems.forEach(item => {
                item.addEventListener('click', function(ev) {
                ev.stopPropagation();
                const selectedValue = ev.target.getAttribute('data-value');
                if (selectedValue) {
                const displaySpan = newDD.querySelector('span:first-child');
                if (displaySpan) {
                displaySpan.textContent = selectedValue;
                }
                const menu = newDD.querySelector('.dropdown-menu');
                if (menu) menu.classList.remove('active');
                }
                });
                });
                });

                // Nav tabs
                const navTabs = document.querySelectorAll('.nav-tab');
                navTabs.forEach(tab => {
                // Remove existing handlers
                const newTab = tab.cloneNode(true);
                tab.parentNode.replaceChild(newTab, tab);

                newTab.addEventListener('click', function(e) {
                const action = e.target.dataset.click;
                if (action === 'production') {
                anvil.call(e.target, 'open_production_form');
                } else if (action === 'templates') {
                anvil.call(e.target, 'open_templates_form');
                } else if (action === 'archives') {
                anvil.call(e.target, 'open_archives_form');
                } else if (action === 'settings') {
                anvil.call(e.target, 'open_settings_form');
                }
                });
                });

                // Bottom buttons
                const bottomButtons = document.querySelectorAll('.bottom-button');
                bottomButtons.forEach(btn => {
                // Remove existing handlers
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);

                newBtn.addEventListener('click', function(e) {
                const action = e.target.dataset.click;
                if (action === 'statut') {
                anvil.call(e.target, 'on_statut_clicked')
                .then(function(chosenStatus) {
                if (chosenStatus) {
                e.target.textContent = chosenStatus;
                }
                })
                .catch(function(error) {
                console.error("[DEBUG] Error in status handling:", error);
                });
                } else if (action === 'enregistrer') {
                window.saveContent(e);
                } else if (action === 'partager') {
                console.log("Share triggered!");
                window.displayBanner("Feature under development by the Checkvet team", "success");
                }
                });
                });

                // Session refresh handlers
                window.addEventListener('online', function() {
                console.log("[DEBUG] Application back online, refreshing session");
                anvil.call(document.body, 'refresh_session_relay');
                });

                document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible') {
                console.log("[DEBUG] Application visible again, checking session");
                anvil.call(document.body, 'refresh_session_relay');
                }
                });

                // Listen for visibility changes to re-request wake lock
                document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible' && window.wakeLockController) {
                window.wakeLockController.requestWakeLock();
                }
                });

                // Check for iOS and set up iOS-specific enhancements
                if (window.recordingState.isIOS) {
                window.setupIOSSupport();
                }

                // Update time on load
                window.updateTime();

                // Initial wake lock request
                window.wakeLockController.requestWakeLock();

                console.log(`[DEBUG] Audio manager event listeners attached. iOS detection: ${window.recordingState.isIOS}`);
                };

                // Set up regular time updates
                setInterval(window.updateTime, 60000);
                }

                // --------------------------------------------------------------------------------------------
                // GOLDEN RULE 3: Immediately Attach Everything
                // --------------------------------------------------------------------------------------------
                window.__attachAudioManagerEvents();

                // Add some debug output to help identify initialization issues
                console.log("[DEBUG JS] Audio manager script loaded and initialized");
                console.log("[DEBUG JS] Key functions:", {
                rebuildPatientSearchInput: typeof window.rebuildPatientSearchInput === 'function' ? 'defined' : 'undefined',
                renderTemplates: typeof window.renderTemplates === 'function' ? 'defined' : 'undefined',
                populateTemplateModal: typeof window.populateTemplateModal === 'function' ? 'defined' : 'undefined'
                });
                </script>
        </body>
      </html>
  type: HtmlTemplate
is_package: true
