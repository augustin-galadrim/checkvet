components:
- layout_properties: {slot: recorder_slot}
  name: recording_widget_1
  properties: {}
  type: form:Components.RecordingWidget
- layout_properties: {slot: playback_slot}
  name: audio_playback_1
  properties: {}
  type: form:Components.AudioPlayback
container:
  properties:
    html: |-
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Offline Audio Recorder</title>
          <style>
            /* Base styles */
            * { box-sizing: border-box; font-family: Arial, sans-serif; margin: 0; padding: 0; }
            body { background-color: #f5f5f5; height: 100vh; overflow: hidden; }
            .container { display: flex; flex-direction: column; height: 100vh; width: 100%; max-width: 800px; margin: 0 auto; background-color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

            /* Header and Actions */
            .fixed-section { background: white; z-index: 10; }
            .actions-row { display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; }
            .time { color: #666; font-size: 14px; }

            /* Scrollable content */
            .scrollable-content { flex: 1; padding: 20px; text-align: center; overflow-y: auto; }
            .instructions { margin: 20px 0; color: #555; }

            /* NEW: Copied from AudioManagerForm */
            #audioDecisionContainer {
              display: none;
              padding: 10px 0;
              display: flex;
              justify-content: center;
              gap: 15px;
              margin-top: 15px;
            }
            .decision-button {
              padding: 10px 20px;
              border-radius: 4px;
              border: 1px solid #ddd;
              cursor: pointer;
              font-size: 14px;
              font-weight: bold;
            }
            .btn-discard { background-color: #f44336; color: white; border-color: #f44336; }
            .btn-queue { background-color: #4CAF50; color: white; border-color: #4CAF50; }

            /* Queue Button in Header */
            .queue-button { padding: 8px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px; }
            .queue-badge { background-color: #f44336; color: white; border-radius: 50%; padding: 2px 6px; font-size: 11px; font-weight: bold; min-width: 18px; text-align: center; display: none; }

            /* Modals (Queue and Title Input) */
            .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center; }
            .modal-content { position: relative; background-color: white; padding: 20px; width: 90%; max-width: 500px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
            .modal-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; }
            .modal-body p { margin-bottom: 15px; }
            .modal-body label { font-weight: bold; margin-bottom: 5px; display: block; }
            .modal-body input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; margin-bottom: 15px; }
            .modal-footer { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
            .queue-list { max-height: 300px; overflow-y: auto; }
            .queue-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
            .queue-item-title { font-weight: bold; }
            .queue-item-status { font-size: 12px; color: #666; margin-top: 4px; }
            .queue-item-actions button { margin-left: 10px; }
            .button { padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; cursor: pointer; }
            .button-primary { background-color: #4CAF50; color: white; border-color: #4CAF50; }
            .button[disabled] { background-color: #ccc; border-color: #ccc; cursor: not-allowed; }

            /* Banner for notifications */
            #bannerContainer { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; }
            .banner { margin-bottom: 10px; padding: 10px 20px; border-radius: 4px; color: #fff; text-align: center; }
            .banner-success { background-color: #4caf50; }
            .banner-error { background-color: #f44336; }
          </style>
        </head>
        <body>
          <div class="container" id="offline-form-stable-anchor">
            <div class="fixed-section">
              <div class="actions-row">
                <button class="queue-button" id="viewQueueBtn">
                  <span>Queue</span>
                  <span class="queue-badge" id="queueBadge">0</span>
                </button>
                <div class="time" id="timeDisplay">--:--</div>
              </div>
            </div>

            <div class="scrollable-content">
              <h2>Offline Recorder</h2>
              <p class="instructions">Record your audio. It will be saved to your device's queue.</p>

              <!-- REFACTORED: Copied structure from AudioManagerForm -->
              <div id="audioInputContainer">
                <div anvil-slot="recorder_slot"></div>
              </div>

              <div id="audioDecisionContainer">
                <div anvil-slot="playback_slot"></div>
                <button id="discard-audio-btn" class="decision-button btn-discard">Discard</button>
                <button id="queue-audio-btn" class="decision-button btn-queue">Put in Queue</button>
              </div>

            </div>
          </div>

          <!-- Banner container for notifications -->
          <div id="bannerContainer"></div>

          <!-- Modal for Naming the Recording -->
          <div class="modal" id="titleModal">
            <div class="modal-content">
              <div class="modal-header">Name Your Recording</div>
              <div class="modal-body">
                <p>Provide a title for this recording to identify it in the queue.</p>
                <label for="recordingTitle">Recording Title:</label>
                <input type="text" id="recordingTitle" placeholder="e.g., Exam of 'Fido'">
              </div>
              <div class="modal-footer">
                <button class="button" id="cancelTitleBtn">Cancel</button>
                <button class="button button-primary" id="confirmTitleBtn">Save to Queue</button>
              </div>
            </div>
          </div>

          <!-- Modal for Viewing the Queue -->
          <div class="modal" id="queueModal">
            <div class="modal-content">
              <div class="modal-header">Offline Recordings Queue</div>
              <div class="modal-body">
                <div class="queue-list" id="queueListContainer"></div>
              </div>
              <div class="modal-footer">
                <button class="button" id="closeQueueModalBtn">Close</button>
              </div>
            </div>
          </div>

          <script>
            if (!window.__offline_form_globals) {
              window.__offline_form_globals = true;

              let db;

              // --- IndexedDB Functions ---
              function initDB() {
                return new Promise((resolve, reject) => {
                  const request = indexedDB.open('audioQueueDB', 1);
                  request.onerror = event => reject("IndexedDB error: " + event.target.errorCode);
                  request.onsuccess = event => {
                    db = event.target.result;
                    console.log("Database initialized successfully.");
                    resolve(db);
                  };
                  request.onupgradeneeded = event => {
                    event.target.result.createObjectStore('recordings', { keyPath: 'id' });
                  };
                });
              }

              // *** FIX IS HERE: Modified save function ***
              async function saveCurrentRecordingToQueue(title) {
                if (!db) {
                  return displayBanner("Database not initialized.", "error");
                }

                const stableAnchor = document.getElementById('offline-form-stable-anchor');
                // get_current_audio_blob() returns the Anvil Media Object, which wraps the JS Blob
                const audioBlob = await anvil.call(stableAnchor, 'get_current_audio_blob');

                if (!audioBlob) {
                  return displayBanner("Error: No audio data to save.", "error");
                }

                // Convert the Blob to an ArrayBuffer for safe storage.
                const audioData = await audioBlob.arrayBuffer();
                const mimeType = audioBlob.type; // e.g., 'audio/mp4'

                const metadata = {
                  id: `rec_${Date.now()}`,
                  timestamp: Date.now(),
                  status: "queued",
                  title: title || "Untitled Recording",
                };

                // Store the ArrayBuffer and mimeType, NOT the Blob object itself.
                const record = { ...metadata, audioData: audioData, mimeType: mimeType };

                const request = db.transaction(['recordings'], 'readwrite')
                  .objectStore('recordings')
                  .add(record);

                request.onsuccess = () => {
                  console.log("Successfully saved raw audio data to IndexedDB.");
                  displayBanner(`'${metadata.title}' saved to offline queue.`, "success");
                  anvil.call(stableAnchor, 'reset_ui_to_recording');
                  updateQueueBadge();
                };
                request.onerror = (event) => {
                  console.error("Error saving to IndexedDB:", event.target.error);
                  displayBanner("Failed to save recording to queue.", "error");
                };
              }
              // *** END OF FIX ***

              function getQueuedRecordings() {
                return new Promise((resolve) => {
                  if (!db) return resolve([]);
                  const request = db.transaction(['recordings'], 'readonly').objectStore('recordings').getAll();
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = () => resolve([]);
                });
              }

              function deleteRecordingFromQueue(id) {
                if (!db) return;
                db.transaction(['recordings'], 'readwrite').objectStore('recordings').delete(id);
                updateQueueBadge();
                renderQueue();
              }

              async function updateQueueBadge() {
                const queue = await getQueuedRecordings();
                const badge = document.getElementById('queueBadge');
                badge.style.display = queue.length > 0 ? 'inline-block' : 'none';
                badge.textContent = queue.length;
              }
              async function renderQueue() {
                const queue = await getQueuedRecordings();
                const container = document.getElementById('queueListContainer');
                container.innerHTML = queue.length === 0 ? '<p>No recordings in queue.</p>' : '';
                queue.forEach(item => {
                  const div = document.createElement('div');
                  div.className = 'queue-item';
                  div.innerHTML = `
                                <div>
                                  <div class="queue-item-title">${item.title}</div>
                                  <div class="queue-item-status">Status: <strong>${item.status}</strong></div>
                                </div>
                                <div class="queue-item-actions">
                                  <button class="button" disabled title="Import is only available in online mode">Import</button>
                                  <button class="button delete-btn" data-id="${item.id}">Delete</button>
                                </div>
                              `;
                  container.appendChild(div);
                });
                document.getElementById('queueModal').style.display = 'flex';
              }

              window.displayBanner = function(message, type) {
                const container = document.getElementById('bannerContainer');
                const banner = document.createElement('div');
                banner.className = `banner banner-${type}`;
                banner.textContent = message;
                container.appendChild(banner);
                setTimeout(() => banner.remove(), 3000);
              };

              window.setAudioWorkflowState = (state) => {
                console.log(`Setting audio workflow state to: ${state}`);
                const inputContainer = document.getElementById('audioInputContainer');
                const decisionContainer = document.getElementById('audioDecisionContainer');

                if (state === 'decision') {
                  if(inputContainer) inputContainer.style.display = 'none';
                  if(decisionContainer) decisionContainer.style.display = 'flex';
                } else { // 'input' state
                  if(inputContainer) inputContainer.style.display = 'block';
                  if(decisionContainer) decisionContainer.style.display = 'none';
                }
              };

              window.openTitleModalForQueueing = () => {
                document.getElementById('recordingTitle').value = '';
                document.getElementById('titleModal').style.display = 'flex';
              };

              window.initializeDBAndQueue = async () => {
                await initDB();
                updateQueueBadge();
              };

              function attachOfflineEvents() {
                const stableAnchor = document.getElementById('offline-form-stable-anchor');
                const reattach = (id, event, handler) => {
                  const el = document.getElementById(id);
                  if(el) {
                    const newEl = el.cloneNode(true);
                    el.parentNode.replaceChild(newEl, el);
                    newEl.addEventListener(event, handler);
                  }
                };
                reattach('viewQueueBtn', 'click', renderQueue);
                reattach('closeQueueModalBtn', 'click', () => document.getElementById('queueModal').style.display = 'none');
                reattach('discard-audio-btn', 'click', () => anvil.call(stableAnchor, 'reset_ui_to_recording'));
                reattach('queue-audio-btn', 'click', () => anvil.call(stableAnchor, 'queue_button_click'));
                reattach('cancelTitleBtn', 'click', () => document.getElementById('titleModal').style.display = 'none');
                reattach('confirmTitleBtn', 'click', () => {
                  const title = document.getElementById('recordingTitle').value;
                  saveCurrentRecordingToQueue(title); // This now calls our robust save function
                  document.getElementById('titleModal').style.display = 'none';
                });

                document.getElementById('queueListContainer').addEventListener('click', (e) => {
                  if (e.target.classList.contains('delete-btn')) {
                    const id = e.target.dataset.id;
                    if (confirm("Are you sure you want to delete this recording?")) {
                      deleteRecordingFromQueue(id);
                    }
                  }
                });

                const timeElem = document.getElementById('timeDisplay');
                const updateTime = () => {
                  const now = new Date();
                  timeElem.textContent = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                };
                updateTime();
                setInterval(updateTime, 60000);
              }
              attachOfflineEvents();
            }
          </script>
        </body>
      </html>
    visible: true
  type: HtmlTemplate
is_package: true
