components:
- layout_properties: {slot: recorder_slot}
  name: recording_widget_1
  properties: {}
  type: form:Components.RecordingWidget
- layout_properties: {slot: default}
  name: header_nav_1
  properties: {active_tab: Production}
  type: form:Components.HeaderNav
container:
  properties:
    html: "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Offline Audio Recorder</title>\n  \n  <!-- Add RecordRTC for iOS compatibility -->\n  <script src=\"https://www.webrtc-experiment.com/RecordRTC.js\"></script>\n  \n  <!-- Add NoSleep.js for fallback wake lock on older browsers -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/nosleep/0.12.0/NoSleep.min.js\"></script>\n  \n  <style>\n    /* Base styles */\n    * {\n      box-sizing: border-box;\n      font-family: Arial, sans-serif;\n      margin: 0;\n      padding: 0;\n    }\n    \n    body {\n      background-color: #f5f5f5;\n      height: 100vh;\n      overflow: hidden;\n    }\n    \n    .container {\n      display: flex;\n      flex-direction: column;\n      height: 100vh;\n      width: 100%;\n      max-width: 800px;\n      margin: 0 auto;\n      background-color: white;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n    }\n    \n    /* Fixed section (nav tabs + actions) */\n    .fixed-section {\n      background: white;\n      z-index: 10;\n    }\n    \n    .nav-tabs {\n      display: flex;\n      width: 100%;\n      border-bottom: 1px solid #ddd;\n    }\n    \n    .nav-tab {\n      flex: 1;\n      padding: 8px 16px;\n      cursor: pointer;\n      border: 1px solid #ccc;\n      border-bottom: none;\n      background: #f8f8f8;\n      font-size: 14px;\n      position: relative;\n      margin-right: -1px;\n      text-align: center;\n    }\n    \n    .nav-tab.active {\n      background: #e5e5e5;\n      border-top: 1px solid #999;\n      border-left: 1px solid #999;\n      border-right: 1px solid #999;\n      border-bottom: 1px solid #e5e5e5;\n      margin-bottom: -1px;\n    }\n    \n    .actions-row {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding: 15px 20px;\n    }\n    \n    .time {\n      color: #666;\n      font-size: 14px;\n    }\n    \n    .connection-status {\n      display: flex;\n      align-items: center;\n      padding: 5px 10px;\n      border-radius: 4px;\n      background: #f0f0f0;\n    }\n    \n    .status-indicator {\n      width: 12px;\n      height: 12px;\n      border-radius: 50%;\n      margin-right: 8px;\n    }\n    \n    .status-online {\n      background-color: #4caf50;\n    }\n    \n    .status-offline {\n      background-color: #f44336;\n    }\n    \n    /* Scrollable content */\n    .scrollable-content {\n      flex: 1;\n      padding: 20px;\n      overflow-y: auto;\n      padding-bottom: 40px;\n    }\n    \n    /* Recording controls */\n    .recording-controls {\n      position: relative;\n      width: 200px;\n      height: 200px;\n      margin: 20px auto;\n    }\n    \n    #circularProgress {\n      position: relative;\n      width: 200px;\n      height: 200px;\n      margin: 0 auto;\n      border-radius: 50%;\n      overflow: hidden;\n    }\n    \n    #progressRing {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      border-radius: 50%;\n      background: conic-gradient(#ddd 0deg, #ddd 0deg);\n    }\n    \n    #centerHole {\n      position: absolute;\n      top: 8px;\n      left: 8px;\n      width: 184px;\n      height: 184px;\n      background-color: #fff;\n      border-radius: 50%;\n      z-index: 1;\n    }\n    \n    .control-button-group {\n      position: absolute;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 30px;\n      z-index: 2;\n    }\n    \n    .control-button {\n      width: 45px;\n      height: 45px;\n      border: 1px solid #666;\n      border-radius: 2px;\n      cursor: pointer;\n      background-color: white;\n      color: #666;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      font-size: 24px;\n      transition: all 0.3s ease;\n      padding: 0;\n    }\n    \n    .control-button svg {\n      pointer-events: none;\n    }\n    \n    .control-button:hover {\n      background-color: #f5f5f5;\n      border-color: #333;\n      color: #333;\n    }\n    \n    @keyframes recordingFlash {\n      0% { background: conic-gradient(#ffe5e5 0deg, #ffe5e5 360deg); }\n      50% { background: conic-gradient(#ffffff 0deg, #ffffff 360deg); }\n      100% { background: conic-gradient(#ffe5e5 0deg, #ffe5e5 360deg); }\n    }\n    \n    .recording-flash {\n      animation: recordingFlash 1.5s infinite;\n    }\n    \n    /* Queue section */\n    .queue-section {\n      margin-top: 40px;\n      padding: 15px;\n      border: 1px solid #ddd;\n      border-radius: 8px;\n      background: #f9f9f9;\n    }\n    \n    .queue-section h3 {\n      margin-bottom: 10px;\n      font-size: 16px;\n      color: #333;\n    }\n    \n    .queue-container {\n      max-height: 200px;\n      overflow-y: auto;\n    }\n    \n    .queue-item {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding: 8px 12px;\n      margin-bottom: 6px;\n      background: white;\n      border-radius: 4px;\n      border-left: 3px solid #2196F3;\n    }\n    \n    .queue-item-right {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n    }\n    \n    .status-badge {\n      padding: 2px 6px;\n      border-radius: 3px;\n      font-size: 12px;\n      font-weight: bold;\n    }\n    \n    .status-badge.pending {\n      background: #ffeb3b;\n      color: #333;\n    }\n    \n    .status-badge.processing {\n      background: #2196F3;\n      color: white;\n    }\n    \n    .status-badge.processed {\n      background: #4caf50;\n      color: white;\n    }\n    \n    .status-badge.error {\n      background: #f44336;\n      color: white;\n    }\n    \n    .remove-queue-btn {\n      background: none;\n      border: none;\n      color: #f44336;\n      font-size: 18px;\n      font-weight: bold;\n      cursor: pointer;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      width: 24px;\n      height: 24px;\n      border-radius: 50%;\n      padding: 0;\n    }\n    \n    .remove-queue-btn:hover {\n      background-color: #f0f0f0;\n    }\n    \n    /* Banners for temporary messages */\n    #bannerContainer {\n      position: fixed;\n      top: 20px;\n      left: 50%;\n      transform: translateX(-50%);\n      z-index: 2000;\n    }\n    \n    .banner {\n      margin-bottom: 10px;\n      padding: 10px 20px;\n      border-radius: 4px;\n      color: #fff;\n      opacity: 0.9;\n      font-size: 14px;\n      min-width: 200px;\n      text-align: center;\n    }\n    \n    .banner-success {\n      background-color: #4caf50;\n    }\n    \n    .banner-error {\n      background-color: #f44336;\n    }\n    \n    /* Transcription display */\n    #transcriptionContainer {\n      margin-top: 30px;\n    }\n    \n    /* Modals */\n    .modal {\n      display: none;\n      position: fixed;\n      top: 0; left: 0;\n      width: 100%; height: 100%;\n      background: rgba(0,0,0,0.5);\n      z-index: 1000;\n    }\n    \n    .modal-content {\n      position: relative;\n      background: white;\n      width: 90%; max-width: 400px;\n      margin: 15% auto; padding: 20px;\n      border-radius: 8px;\n    }\n    \n    .modal-close {\n      position: absolute;\n      top: 10px; right: 10px;\n      background: none;\n      border: none;\n      font-size: 18px;\n      cursor: pointer;\n    }\n    \n    .form-group {\n      margin-bottom: 15px;\n    }\n    \n    .form-group label {\n      display: block;\n      margin-bottom: 5px;\n      font-weight: bold;\n      font-size: 14px;\n    }\n    \n    .form-group select,\n    .form-group input {\n      width: 100%;\n      padding: 8px;\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      font-size: 14px;\n    }\n    \n    .submit-btn {\n      width: 100%;\n      padding: 10px;\n      background: #4caf50;\n      color: white;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n      font-size: 16px;\n      margin-top: 10px;\n    }\n    \n    .submit-btn:hover {\n      background: #45a049;\n    }\n    \n    .patient-item {\n      padding: 8px;\n      border-bottom: 1px solid #ddd;\n      cursor: pointer;\n    }\n    \n    .patient-item:hover {\n      background-color: #f0f0f0;\n    }\n    \n    /* Responsive styles */\n    @media (max-width: 600px) {\n      .recording-controls {\n        width: 180px;\n        height: 180px;\n      }\n      \n      #circularProgress {\n        width: 180px;\n        height: 180px;\n      }\n      \n      #centerHole {\n        top: 7px; left: 7px;\n        width: 166px; height: 166px;\n      }\n      \n      .control-button {\n        width: 40px; height: 40px;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <!-- Fixed section: Tabs + Actions -->\n    <div class=\"fixed-section\">\n      <div anvil-slot=\"default\"></div>\n      <div class=\"actions-row\">\n        <div class=\"connection-status\">\n          <div id=\"connectionIndicator\" class=\"status-indicator status-online\"></div>\n          <span id=\"connectionStatus\">Online</span>\n        </div>\n        <div class=\"time\" id=\"timeDisplay\">--:--</div>\n      </div>\n    </div>\n    \n    <!-- Main content area -->\n    <div class=\"scrollable-content\">\n      <h2 style=\"text-align: center; margin-bottom: 20px;\">Audio Recorder</h2>\n      \n      <!-- Recording controls -->\n      <div class=\"recording-controls\">\n        <div anvil-slot=\"recorder_slot\"></div>\n      </div>\n      \n      <div style=\"text-align: center; margin: 20px 0;\">\n        <p>\n          Click the microphone to start recording.<br>\n          Click the checkmark when finished.\n        </p>\n      </div>\n      \n      <!-- Transcription Display -->\n      <div id=\"transcriptionContainer\" class=\"transcription-container\" style=\"display: none; margin-top: 30px;\">\n        <h3>Transcription</h3>\n        <div id=\"transcriptionText\" class=\"transcription-text\" style=\"padding: 15px; border: 1px solid #ddd; border-radius: 5px; margin-top: 10px; max-height: 200px; overflow-y: auto; background-color: #f9f9f9;\"></div>\n      </div>\n      \n      <!-- Offline Queue Section -->\n      <div id=\"queueSection\" class=\"queue-section\" style=\"display: none;\">\n        <h3>Offline Recordings Queue</h3>\n        <div id=\"queueContainer\" class=\"queue-container\">\n          <!-- Queue items will be inserted here dynamically -->\n        </div>\n      </div>\n      \n      <audio id=\"audioPlayback\" style=\"display: none;\"></audio>\n    </div>\n  </div>\n  \n  <!-- Banners for messages -->\n  <div id=\"bannerContainer\"></div>\n  \n  <!-- Title Modal (simplified from previous Recording Info Modal) -->\n  <div id=\"titleModal\" class=\"modal\">\n    <div class=\"modal-content\">\n      <button class=\"modal-close\" id=\"closeTitleModalBtn\">&times;</button>\n      <h3 style=\"margin-bottom: 15px;\">Name Your Recording</h3>\n      \n      <div class=\"form-group\">\n        <label for=\"recordingTitle\">Title:</label>\n        <input type=\"text\" id=\"recordingTitle\" placeholder=\"Enter a title for this recording\">\n      </div>\n      \n      <button id=\"saveTitleBtn\" class=\"submit-btn\">Save & Process</button>\n    </div>\n  </div>\n  \n  <!-- Main JavaScript -->\n  <script>\n    // --------------------------------------------------------------------------------------------\n    // GLOBAL INITIALIZATION\n    // --------------------------------------------------------------------------------------------\n    if (!window.__my_offline_audio_manager_globals) {\n      window.__my_offline_audio_manager_globals = true;\n      \n      // --------------------------------------------------------------------------------------------\n      // Wake lock initialization (Screen Wake Lock API + NoSleep.js fallback)\n      // --------------------------------------------------------------------------------------------\n      window.wakeLockController = {\n        wakeLock: null,\n        noSleep: null,\n        \n        init: function() {\n          if (!this.noSleep) {\n            this.noSleep = new NoSleep();\n          }\n        },\n        \n        requestWakeLock: function() {\n          this.init();\n          // Try Screen Wake Lock API\n          if ('wakeLock' in navigator) {\n            navigator.wakeLock.request('screen')\n              .then((lock) => {\n                console.log('Wake Lock activated with Screen Wake Lock API');\n                this.wakeLock = lock;\n                this.wakeLock.addEventListener('release', () => {\n                  console.log('Wake Lock was released by the system');\n                });\n              })\n              .catch((err) => {\n                console.log('Failed to activate Screen Wake Lock API, falling back to NoSleep.js:', err);\n                this.noSleep.enable();\n              });\n          } else {\n            console.log('Screen Wake Lock API not supported, using NoSleep.js');\n            this.noSleep.enable();\n          }\n        },\n        \n        releaseWakeLock: function() {\n          if (this.wakeLock) {\n            this.wakeLock.release()\n              .then(() => {\n                this.wakeLock = null;\n                console.log('Wake Lock released');\n              });\n          }\n          if (this.noSleep) {\n            this.noSleep.disable();\n          }\n        }\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Platform and state detection\n      // --------------------------------------------------------------------------------------------\n      // Detect if the platform is iOS\n      window.isIOS = function() {\n        return /iPhone|iPad|iPod/i.test(navigator.userAgent || navigator.vendor || (window.opera && opera.toString() === '[object Opera]'));\n      };\n      \n      // Global data\n      window.audioManagerData = {\n        mediaRecorder: null,\n        recordedChunks: [],\n        audioBlob: null,\n        stream: null,\n        isRecording: false,\n        isIOS: window.isIOS(),\n        recordRTC: null,\n        selectedPatient: null,\n        selectedTemplate: null,\n        selectedLanguage: \"EN\"\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Utility functions\n      // --------------------------------------------------------------------------------------------\n      // Get browser's online status\n      window.getBrowserOnlineStatus = function() {\n        return navigator.onLine;\n      };\n      \n      window.storeAudioInQueue = function(audioBlob, metadata) {\n        console.log(\"storeAudioInQueue called\", { \n          blobPresent: !!audioBlob, \n          blobType: audioBlob ? audioBlob.type : 'none',\n          blobSize: audioBlob ? audioBlob.size : 0,\n          metadata \n        });\n        \n        try {\n          // First, check if the blob is valid\n          if (!audioBlob || audioBlob.size === 0) {\n            console.error(\"Invalid audio blob in storeAudioInQueue\");\n            window.displayBanner(\"Error: Recording data is invalid\", \"error\");\n            return false;\n          }\n          \n          // Store directly as arrayBuffer rather than base64\n          return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = function() {\n              try {\n                // Get array buffer from the reader\n                const arrayBuffer = reader.result;\n                \n                // Convert to Uint8Array for more reliable serialization\n                const uint8Array = new Uint8Array(arrayBuffer);\n                \n                // Convert to regular array for JSON serialization\n                const numberArray = Array.from(uint8Array);\n                \n                // Retrieve existing queue\n                let queue = [];\n                try {\n                  const storedQueue = localStorage.getItem('audioQueue');\n                  queue = storedQueue ? JSON.parse(storedQueue) : [];\n                  if (!Array.isArray(queue)) queue = [];\n                } catch (e) {\n                  console.error(\"Error parsing queue from localStorage:\", e);\n                  // Reset the queue if it's corrupted\n                  queue = [];\n                }\n                \n                // Add new recording to queue with binary data instead of base64\n                queue.push({\n                  audio: numberArray,\n                  metadata: metadata\n                });\n                \n                // Save back to localStorage\n                try {\n                  localStorage.setItem('audioQueue', JSON.stringify(queue));\n                  console.log(\"Recording saved to queue. Queue size:\", queue.length);\n                  window.updateQueueDisplay();\n                  window.displayQueueSection();\n                  resolve(true);\n                } catch (e) {\n                  console.error(\"Error saving queue to localStorage:\", e);\n                  \n                  // If the error is a quota exceeded error, try to truncate the data\n                  if (e.name === 'QuotaExceededError' || e.code === 22) {\n                    window.displayBanner(\"Storage limit reached. Clearing old recordings.\", \"error\");\n                    // Keep only the most recent recording\n                    localStorage.setItem('audioQueue', JSON.stringify([{\n                      audio: numberArray,\n                      metadata: metadata\n                    }]));\n                    window.updateQueueDisplay();\n                    window.displayQueueSection();\n                    resolve(true);\n                  } else {\n                    window.displayBanner(\"Error saving to local storage\", \"error\");\n                    reject(e);\n                  }\n                }\n              } catch (e) {\n                console.error(\"Error processing audio data in reader.onload:\", e);\n                window.displayBanner(\"Error processing audio data\", \"error\");\n                reject(e);\n              }\n            };\n            \n            reader.onerror = function(error) {\n              console.error(\"FileReader error:\", error);\n              window.displayBanner(\"Error reading audio data\", \"error\");\n              reject(error);\n            };\n            \n            // Read as ArrayBuffer instead of data URL for more reliable handling\n            reader.readAsArrayBuffer(audioBlob);\n          })\n          .then(result => {\n            return true; // Return true to Python\n          })\n          .catch(error => {\n            console.error(\"Promise error in storeAudioInQueue:\", error);\n            return false; // Return false to Python\n          });\n        } catch (e) {\n          console.error(\"Unexpected error in storeAudioInQueue:\", e);\n          window.displayBanner(\"Unexpected error saving recording\", \"error\");\n          return false;\n        }\n      };\n      \n      // Modified: Process queue item - send entire item metadata to Python\n      window.processQueueItem = function(item) {\n        return new Promise((resolve, reject) => {\n          try {\n            if (!item || !item.metadata || !item.metadata.id) {\n              console.error(\"Invalid queue item:\", item);\n              reject(new Error(\"Invalid queue item\"));\n              return;\n            }\n            \n            const itemId = item.metadata.id;\n            console.log(`Processing queue item: ${itemId}`);\n            \n            // Update status to processing\n            window.updateItemStatus(itemId, \"processing\");\n            \n            // Make sure we have audio data\n            if (!item.audio || !Array.isArray(item.audio)) {\n              console.error(\"No audio data in item:\", item);\n              window.updateItemStatus(itemId, \"error\");\n              reject(new Error(\"No audio data\"));\n              return;\n            }\n            \n            // Get a reference to a safe element for the anvil call\n            const safeElement = document.getElementById(\"stopButton\");\n            if (!safeElement) {\n              console.error(\"Safe element not found for anvil call\");\n              window.updateItemStatus(itemId, \"error\");\n              reject(new Error(\"Safe element not found\"));\n              return;\n            }\n            \n            // Convert the array to a Uint8Array\n            const uint8Array = new Uint8Array(item.audio);\n            \n            // Send the Uint8Array and metadata to Python\n            anvil.call(safeElement, \"process_queued_audio\", itemId, uint8Array, item.metadata)\n              .then(result => {\n                console.log(`Item ${itemId} processed, result: ${result}`);\n                if (result === \"OK\") {\n                  window.updateItemStatus(itemId, \"processed\");\n                  resolve(true);\n                } else {\n                  window.updateItemStatus(itemId, \"error\");\n                  reject(new Error(\"Processing failed\"));\n                }\n              })\n              .catch(error => {\n                console.error(`Error processing item ${itemId}:`, error);\n                window.updateItemStatus(itemId, \"error\");\n                reject(error);\n              });\n          } catch (error) {\n            console.error(\"Error in processQueueItem:\", error);\n            if (item && item.metadata && item.metadata.id) {\n              window.updateItemStatus(item.metadata.id, \"error\");\n            }\n            reject(error);\n          }\n        });\n      };\n      \n      // Add function to remove a queue item\n      window.removeQueueItem = function(itemId) {\n        console.log(`Removing item ${itemId} from queue`);\n        \n        try {\n            let queue = JSON.parse(localStorage.getItem('audioQueue') || '[]');\n            if (!Array.isArray(queue)) queue = [];\n            \n            // Filter out the item with the specified ID\n            let newQueue = queue.filter(item => \n                !item.metadata || item.metadata.id !== itemId\n            );\n            \n            localStorage.setItem('audioQueue', JSON.stringify(newQueue));\n            console.log(`Removed item ${itemId}. Queue now has ${newQueue.length} items`);\n            \n            // Update the display\n            window.updateQueueDisplay();\n            \n            // Hide if empty and online\n            if (newQueue.length === 0 && window.getBrowserOnlineStatus()) {\n                document.getElementById('queueSection').style.display = 'none';\n            }\n            \n            window.displayBanner(\"Recording removed from queue\", \"success\");\n            return true;\n        } catch (e) {\n            console.error(`Error removing queue item ${itemId}:`, e);\n            window.displayBanner(\"Error removing recording\", \"error\");\n            return false;\n        }\n      };\n      \n      // FIXED: Improved queue processing\n      window.processEntireQueue = function() {\n        return new Promise((resolve, reject) => {\n          try {\n            // Get the queue data\n            const storedData = localStorage.getItem('audioQueue');\n            if (!storedData) {\n              console.log(\"No queue data found\");\n              resolve({ processed: 0, errors: 0 });\n              return;\n            }\n            \n            const queue = JSON.parse(storedData);\n            if (!Array.isArray(queue) || queue.length === 0) {\n              console.log(\"Queue is empty\");\n              resolve({ processed: 0, errors: 0 });\n              return;\n            }\n            \n            console.log(`Processing ${queue.length} items in queue`);\n            \n            // Get a safe element for anvil calls\n            const safeElement = document.getElementById(\"stopButton\");\n            if (!safeElement) {\n              reject(new Error(\"No safe element found for anvil calls\"));\n              return;\n            }\n            \n            // Tell Python about all queued items (just metadata)\n            anvil.call(safeElement, \"begin_queue_processing\", queue.length)\n              .then(() => {\n                // Process items one by one\n                let promise = Promise.resolve();\n                let processed = 0;\n                let errors = 0;\n                \n                queue.forEach((item, index) => {\n                  promise = promise.then(() => {\n                    if (!item.audio || !Array.isArray(item.audio)) {\n                      errors++;\n                      return Promise.resolve();\n                    }\n                    \n                    return window.processQueueItem(item)\n                      .then(() => {\n                        processed++;\n                      })\n                      .catch(err => {\n                        console.error(`Error processing item ${index}:`, err);\n                        errors++;\n                      });\n                  });\n                });\n                \n                return promise.then(() => {\n                  window.removeProcessedItems();\n                  \n                  // Show a success message if any items were processed\n                  if (processed > 0) {\n                    window.displayBanner(`${processed} recordings processed successfully`, \"success\");\n                  }\n                  \n                  resolve({ processed, errors });\n                });\n              })\n              .catch(reject);\n          } catch (error) {\n            console.error(\"Error in processEntireQueue:\", error);\n            reject(error);\n          }\n        });\n      };\n      \n      window.setRingPercentage = function(percentage) {\n        const ringElem = document.getElementById(\"progressRing\");\n        const clamped = Math.max(0, Math.min(100, percentage));\n        const angle = (clamped / 100) * 360;\n        if (ringElem) {\n          ringElem.style.background = `conic-gradient(#4caf50 ${angle}deg, #ddd ${angle}deg)`;\n        }\n      };\n      \n      window.startRecordingFlash = function() {\n        const ringElem = document.getElementById(\"progressRing\");\n        if (ringElem) { ringElem.classList.add(\"recording-flash\"); }\n      };\n      \n      window.stopRecordingFlash = function() {\n        const ringElem = document.getElementById(\"progressRing\");\n        if (ringElem) { ringElem.classList.remove(\"recording-flash\"); }\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Transcription functions\n      // --------------------------------------------------------------------------------------------\n      window.showTranscriptionContainer = function() {\n        const container = document.getElementById('transcriptionContainer');\n        if (container) {\n          container.style.display = 'block';\n        }\n      };\n      \n      window.updateTranscriptionDisplay = function(transcription) {\n        const transcriptionText = document.getElementById('transcriptionText');\n        if (transcriptionText) {\n          transcriptionText.textContent = transcription;\n          // Show the container if it's not already visible\n          window.showTranscriptionContainer();\n        }\n      };\n      \n      window.clearTranscriptionDisplay = function() {\n        const transcriptionText = document.getElementById('transcriptionText');\n        const container = document.getElementById('transcriptionContainer');\n        if (transcriptionText) {\n          transcriptionText.textContent = '';\n        }\n        if (container) {\n          container.style.display = 'none';\n        }\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Audio recording processing \n      // --------------------------------------------------------------------------------------------\n      window.processRecording = async function(blob) {\n        try {\n          window.setRingPercentage(50); // Show 50% progress\n          \n          // Get a reference to the stop button for the call\n          const stopBtn = document.getElementById(\"stopButton\");\n          if (!stopBtn) {\n            console.error(\"Stop button not found for anvil call\");\n            window.displayBanner(\"Interface error. Please reload the page.\", \"error\");\n            return;\n          }\n          \n          try {\n            const result = await anvil.call(stopBtn, \"process_recording\", blob);\n            console.log(\"Recording processing initiated. Server response:\", result);\n            \n            // If result is PENDING_INFO, the modal will be opened by Python\n            // The modal will collect patient and template info\n            \n            window.setRingPercentage(100);\n            window.stopRecordingFlash();\n          } catch (error) {\n            console.error(\"Error processing recording:\", error);\n            window.displayBanner(\"Error processing recording\", \"error\");\n            window.setRingPercentage(0);\n            window.stopRecordingFlash();\n          }\n        } catch (error) {\n          console.error(\"Unhandled error in processRecording:\", error);\n          window.displayBanner(\"An unexpected error occurred\", \"error\");\n          window.setRingPercentage(0);\n          window.stopRecordingFlash();\n        }\n      };\n      \n      // Display banners\n      window.displayBanner = function(message, type) {\n        const bannerContainer = document.getElementById('bannerContainer');\n        if (!bannerContainer) return;\n        \n        const banner = document.createElement('div');\n        banner.className = 'banner ' + (type === 'success' ? 'banner-success' : 'banner-error');\n        banner.textContent = message;\n        bannerContainer.appendChild(banner);\n        \n        setTimeout(() => {\n          banner.style.opacity = '0';\n          setTimeout(() => {\n            if (banner.parentNode) {\n              banner.parentNode.removeChild(banner);\n            }\n          }, 300);\n        }, 3000);\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Recording Info Modal Functions\n      // --------------------------------------------------------------------------------------------\n      window.openTitleModal = function() {\n        const modal = document.getElementById('titleModal');\n        if (!modal) return false;\n        \n        // Reset title field\n        const titleInput = document.getElementById('recordingTitle');\n        if (titleInput) titleInput.value = '';\n        \n        // Show modal\n        modal.style.display = 'block';\n        \n        // Focus the input field\n        if (titleInput) setTimeout(() => titleInput.focus(), 100);\n        \n        return true;\n      };\n      \n      window.closeTitleModal = function() {\n        const modal = document.getElementById('titleModal');\n        if (modal) {\n          modal.style.display = 'none';\n        }\n        return true;\n      };\n      \n      window.saveRecordingTitle = function() {\n        // Get the title\n        const titleInput = document.getElementById('recordingTitle');\n        \n        if (!titleInput) {\n          console.error(\"Title input not found\");\n          window.displayBanner(\"Interface error, please try again\", \"error\");\n          return false;\n        }\n        \n        const title = titleInput.value.trim();\n        \n        if (!title) {\n          window.displayBanner(\"Please enter a title for your recording\", \"error\");\n          return false;\n        }\n        \n        // All validations passed, save the recording with title\n        const safeElement = document.getElementById('stopButton');\n        if (!safeElement) {\n          console.error(\"No safe element found for saving recording\");\n          window.displayBanner(\"Interface error, please try again\", \"error\");\n          return false;\n        }\n        \n        try {\n          anvil.call(safeElement, \"save_recording_with_title\", title)\n            .then(result => {\n              console.log(\"Recording saved with title, result:\", result);\n              window.closeTitleModal();\n            })\n            .catch(error => {\n              console.error(\"Error saving recording with title:\", error);\n              window.displayBanner(\"Error saving recording\", \"error\");\n            });\n        } catch (e) {\n          console.error(\"Error calling save_recording_with_title:\", e);\n          window.displayBanner(\"Error saving recording\", \"error\");\n          return false;\n        }\n        \n        return true;\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Connection status and queue management (AUDIO)\n      // --------------------------------------------------------------------------------------------\n      window.updateConnectionStatusIndicator = function(isOnline) {\n        const indicator = document.getElementById('connectionIndicator');\n        const statusText = document.getElementById('connectionStatus');\n        \n        if (indicator && statusText) {\n          if (isOnline) {\n            indicator.className = 'status-indicator status-online';\n            statusText.textContent = 'Online';\n            // Check if we have items in the queue\n            const queue = window.getQueueData();\n            document.getElementById('queueSection').style.display = \n              (queue && queue.length > 0) ? 'block' : 'none';\n          } else {\n            indicator.className = 'status-indicator status-offline';\n            statusText.textContent = 'Offline - recordings will be queued';\n            // Always show queue section when offline\n            document.getElementById('queueSection').style.display = 'block';\n          }\n        }\n        \n        // Return the status for chaining\n        return isOnline;\n      };\n      \n      // Make the queue section visible\n      window.displayQueueSection = function() {\n        const queueSection = document.getElementById('queueSection');\n        if (queueSection) {\n          queueSection.style.display = 'block';\n          window.updateQueueDisplay();\n        }\n        return true;\n      };\n      \n      window.getQueueData = function() {\n        try {\n          const storedData = localStorage.getItem('audioQueue');\n          if (!storedData) return [];\n          \n          const parsedData = JSON.parse(storedData);\n          console.log(\"Retrieved queue data, length:\", parsedData.length);\n          return Array.isArray(parsedData) ? parsedData : [];\n        } catch (e) {\n          console.error(\"Error retrieving queue data:\", e);\n          // Return empty array if there's an error\n          return [];\n        }\n      };\n      \n      // Updated queue display function to just show title\n      window.updateQueueDisplay = function() {\n        let queue = window.getQueueData();\n        let queueContainer = document.getElementById('queueContainer');\n        let queueSection = document.getElementById('queueSection');\n        \n        if (!queueContainer) return;\n        \n        // Clear current contents\n        queueContainer.innerHTML = '';\n        \n        // Hide section if empty\n        if (!queue || queue.length === 0) {\n          queueContainer.innerHTML = '<p>No recordings in queue</p>';\n          // Only hide if we're online\n          if (window.getBrowserOnlineStatus()) {\n            queueSection.style.display = 'none';\n          }\n          return;\n        }\n        \n        // Show section if there are items\n        queueSection.style.display = 'block';\n        \n        // Create elements for each queue item\n        queue.forEach((item, index) => {\n          try {\n            let queueItem = document.createElement('div');\n            queueItem.className = 'queue-item';\n            \n            // Format timestamp\n            let date = new Date((item.metadata?.timestamp || 0) * 1000);\n            let formattedDate = isNaN(date.getTime()) ? 'Unknown date' : date.toLocaleString();\n            \n            // Get title (or fallback to patient name)\n            let title = item.metadata?.title || \"Untitled Recording\";\n            if (!title && item.metadata?.patient_data?.name) {\n              title = item.metadata.patient_data.name;\n            }\n            \n            // Determine status class\n            let status = item.metadata?.status || 'pending';\n            let statusClass = 'pending';\n            if (status === 'processing') statusClass = 'processing';\n            if (status === 'processed') statusClass = 'processed';\n            if (status === 'error') statusClass = 'error';\n            \n            // Add the remove button\n            const removeBtn = document.createElement('button');\n            removeBtn.className = 'remove-queue-btn';\n            removeBtn.innerHTML = 'Ã—';\n            removeBtn.title = 'Remove from queue';\n            removeBtn.dataset.itemId = item.metadata?.id || '';\n            \n            // Add the text content with title\n            const textDiv = document.createElement('div');\n            textDiv.innerHTML = `\n              <div><strong>${title}</strong></div>\n              <div style=\"font-size: 12px; color: #666;\">${formattedDate}</div>\n            `;\n            \n            // Add the status badge\n            const statusDiv = document.createElement('div');\n            statusDiv.className = `status-badge ${statusClass}`;\n            statusDiv.textContent = status;\n            \n            // Add a flex container for the status and button\n            const rightContainer = document.createElement('div');\n            rightContainer.className = 'queue-item-right';\n            rightContainer.appendChild(statusDiv);\n            rightContainer.appendChild(removeBtn);\n            \n            // Add everything to the queue item\n            queueItem.appendChild(textDiv);\n            queueItem.appendChild(rightContainer);\n            \n            // Add click event for remove button\n            removeBtn.addEventListener('click', function(evt) {\n                evt.stopPropagation(); // Prevent the click from bubbling up\n                const itemId = this.dataset.itemId;\n                if (itemId) {\n                    // Get a safe element for the anvil call\n                    const safeElement = document.getElementById('stopButton');\n                    if (safeElement) {\n                        try {\n                            anvil.call(safeElement, 'remove_queue_item', itemId);\n                        } catch (e) {\n                            console.error(`Error removing queue item ${itemId}:`, e);\n                            window.displayBanner(\"Error removing queue item\", \"error\");\n                        }\n                    } else {\n                        window.removeQueueItem(itemId);\n                    }\n                }\n            });\n            \n            queueContainer.appendChild(queueItem);\n          } catch (e) {\n            console.error(\"Error rendering queue item:\", e);\n          }\n        });\n      };\n      \n      window.updateItemStatus = function(id, status) {\n        console.log(`Updating item ${id} status to ${status}`);\n        \n        try {\n          let queue = JSON.parse(localStorage.getItem('audioQueue') || '[]');\n          if (!Array.isArray(queue)) queue = [];\n          \n          let updated = false;\n          let updatedQueue = queue.map(item => {\n            if (item.metadata && item.metadata.id === id) {\n              item.metadata.status = status;\n              updated = true;\n            }\n            return item;\n          });\n          \n          if (updated) {\n            localStorage.setItem('audioQueue', JSON.stringify(updatedQueue));\n            window.updateQueueDisplay();\n            return true;\n          } else {\n            console.warn(`Item with id ${id} not found in queue`);\n            return false;\n          }\n        } catch (e) {\n          console.error(\"Error updating item status:\", e);\n          return false;\n        }\n      };\n      \n      window.removeProcessedItems = function() {\n        try {\n          let queue = JSON.parse(localStorage.getItem('audioQueue') || '[]');\n          if (!Array.isArray(queue)) queue = [];\n          \n          let remainingQueue = queue.filter(item => \n            !item.metadata || item.metadata.status !== \"processed\"\n          );\n          \n          localStorage.setItem('audioQueue', JSON.stringify(remainingQueue));\n          console.log(`Removed processed items. Queue now has ${remainingQueue.length} items`);\n          \n          window.updateQueueDisplay();\n          \n          // Hide if empty and online\n          if (remainingQueue.length === 0 && window.getBrowserOnlineStatus()) {\n            document.getElementById('queueSection').style.display = 'none';\n          }\n          \n          return true;\n        } catch (e) {\n          console.error(\"Error removing processed items:\", e);\n          return false;\n        }\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Recording control \n      // --------------------------------------------------------------------------------------------\n      window.startIOSRecording = async function(data, button, evt) {\n        try {\n          data.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n          data.recordRTC = new RecordRTC(data.stream, {\n            disableLogs: true,\n            type: 'audio',\n            mimeType: 'audio/wav',\n            recorderType: RecordRTC.StereoAudioRecorder,\n            numberOfAudioChannels: 1,\n            checkForInactiveTracks: true,\n            bufferSize: 16384\n          });\n          data.recordRTC.startRecording();\n          data.isRecording = true;\n          button.innerHTML = window.pauseIconHTML;\n          anvil.call(evt.target, \"start_recording\");\n          window.startRecordingFlash();\n          return true;\n        } catch (e) {\n          console.error(\"Error in startIOSRecording:\", e);\n          window.displayBanner(\"Error starting recording\", \"error\");\n          return false;\n        }\n      };\n      \n      window.micIconHTML = `\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n          <path d=\"M8 11.5a2.5 2.5 0 0 0 2.5-2.5V4a2.5 2.5 0 1 0-5 0v5A2.5 2.5 0 0 0 8 11.5z\"/>\n          <path d=\"M10 5a.5.5 0 0 1 1 0v4a3 3 0 1 1-6 0V5a.5.5 0 0 1 1 0v4a2 2 0 0 0 4 0V5z\"/>\n          <path d=\"M8 13a4.5 4.5 0 0 0 4.5-4.5.5.5 0 0 1 1 0 5.5 5.5 0 0 1-11 0 .5.5 0 0 1 1 0A4.5 4.5 0 0 0 8 13z\"/>\n        </svg>\n      `;\n      window.pauseIconHTML = `\n        <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"16\" height=\"16\">\n          <rect x=\"9\" y=\"2\" width=\"6\" height=\"12\" rx=\"3\" fill=\"currentColor\"/>\n          <path d=\"M6 12a6 6 0 0 0 12 0M12 18v4M8 22h8\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n        </svg>\n      `;\n      \n      // --------------------------------------------------------------------------------------------\n      // Clock display \n      // --------------------------------------------------------------------------------------------\n      window.updateClock = function() {\n        const now = new Date();\n        const hours = now.getHours().toString().padStart(2, '0');\n        const minutes = now.getMinutes().toString().padStart(2, '0');\n        const timeDisplay = document.getElementById('timeDisplay');\n        if (timeDisplay) {\n          timeDisplay.textContent = `${hours}:${minutes}`;\n        }\n      };\n      \n      // --------------------------------------------------------------------------------------------\n      // Attach event listeners\n      // --------------------------------------------------------------------------------------------\n      window.__attachOfflineAudioManagerEvents = function() {\n        const data = window.audioManagerData;\n        \n        // Update the clock\n        window.updateClock();\n        setInterval(window.updateClock, 60000);\n        \n        // Play Button\n        const playButton = document.getElementById(\"playButton\");\n        if (playButton) {\n          playButton.replaceWith(playButton.cloneNode(true));\n          const newPlayButton = document.getElementById(\"playButton\");\n          \n          newPlayButton.addEventListener(\"click\", async (evt) => {\n            window.wakeLockController.requestWakeLock();\n            \n            if (!data.isRecording) {\n              if (data.isIOS) {\n                try {\n                  data.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                  if (typeof RecordRTC === 'undefined') {\n                    const script = document.createElement('script');\n                    script.src = 'https://www.webrtc-experiment.com/RecordRTC.js';\n                    script.onload = function() {\n                      window.startIOSRecording(data, newPlayButton, evt);\n                    };\n                    document.head.appendChild(script);\n                  } else {\n                    window.startIOSRecording(data, newPlayButton, evt);\n                  }\n                } catch (err) {\n                  console.error(\"Error accessing microphone:\", err);\n                  window.displayBanner(\"Microphone access denied or unavailable.\", \"error\");\n                }\n              } else {\n                if (data.mediaRecorder && data.mediaRecorder.state === \"inactive\") {\n                  data.mediaRecorder = null;\n                }\n                if (!data.mediaRecorder) {\n                  try {\n                    data.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                    data.mediaRecorder = new MediaRecorder(data.stream);\n                    data.recordedChunks = [];\n                    data.mediaRecorder.ondataavailable = evt => data.recordedChunks.push(evt.data);\n                    data.mediaRecorder.start();\n                    data.isRecording = true;\n                    newPlayButton.innerHTML = window.pauseIconHTML;\n                    anvil.call(evt.target, \"start_recording\");\n                    window.startRecordingFlash();\n                  } catch (err) {\n                    console.error(\"Error accessing microphone:\", err);\n                    window.displayBanner(\"Microphone access denied or unavailable.\", \"error\");\n                  }\n                } else {\n                  if (data.mediaRecorder.state === \"paused\") {\n                    data.mediaRecorder.resume();\n                    data.isRecording = true;\n                    newPlayButton.innerHTML = window.pauseIconHTML;\n                    anvil.call(evt.target, \"start_recording\");\n                  }\n                }\n              }\n            } else {\n              // Pause\n              if (data.isIOS) {\n                if (data.recordRTC) {\n                  data.recordRTC.pauseRecording();\n                  data.isRecording = false;\n                  newPlayButton.innerHTML = window.micIconHTML;\n                  anvil.call(evt.target, \"pause_recording\");\n                }\n              } else {\n                if (data.mediaRecorder && data.mediaRecorder.state === \"recording\") {\n                  data.mediaRecorder.pause();\n                  data.isRecording = false;\n                  newPlayButton.innerHTML = window.micIconHTML;\n                  anvil.call(evt.target, \"pause_recording\");\n                }\n              }\n            }\n          });\n        }\n        \n        // Stop Button\n        const stopButton = document.getElementById(\"stopButton\");\n        if (stopButton) {\n          stopButton.replaceWith(stopButton.cloneNode(true));\n          const newStopButton = document.getElementById(\"stopButton\");\n          \n          newStopButton.addEventListener(\"click\", (evt) => {\n            console.log(\"Stop button clicked\");\n            if (data.isIOS) {\n              if (data.recordRTC) {\n                data.recordRTC.stopRecording(function() {\n                  try {\n                    const blob = data.recordRTC.getBlob();\n                    if (!blob || blob.size === 0) {\n                      console.error(\"Empty blob from recordRTC\");\n                      window.displayBanner(\"Error: Recording is empty\", \"error\");\n                      return;\n                    }\n                    \n                    console.log(\"Recording stopped, blob size:\", blob.size);\n                    data.audioBlob = blob;\n                    window.processRecording(blob);\n                    anvil.call(evt.target, \"stop_recording\");\n                    \n                    data.recordRTC.destroy();\n                    if (data.stream) {\n                      data.stream.getTracks().forEach(track => track.stop());\n                    }\n                    setTimeout(() => {\n                      data.recordRTC = null;\n                      data.stream = null;\n                    }, 300);\n                  } catch (e) {\n                    console.error(\"Error processing iOS recording:\", e);\n                    window.displayBanner(\"Error processing recording\", \"error\");\n                  }\n                });\n                data.isRecording = false;\n                const playButton = document.getElementById(\"playButton\");\n                if (playButton) playButton.innerHTML = window.micIconHTML;\n              }\n            } else {\n              if (data.mediaRecorder && data.mediaRecorder.state !== \"inactive\") {\n                data.mediaRecorder.onstop = () => {\n                  try {\n                    if (!data.recordedChunks || data.recordedChunks.length === 0) {\n                      console.error(\"No recorded chunks available\");\n                      window.displayBanner(\"Error: No audio data recorded\", \"error\");\n                      return;\n                    }\n                    \n                    const blob = new Blob(data.recordedChunks, { type: 'audio/webm' });\n                    if (!blob || blob.size === 0) {\n                      console.error(\"Empty blob created from chunks\");\n                      window.displayBanner(\"Error: Recording is empty\", \"error\");\n                      return;\n                    }\n                    \n                    console.log(\"Recording stopped, blob size:\", blob.size);\n                    data.audioBlob = blob;\n                    window.processRecording(blob);\n                    anvil.call(evt.target, \"stop_recording\");\n                  } catch (e) {\n                    console.error(\"Error processing recording:\", e);\n                    window.displayBanner(\"Error processing recording\", \"error\");\n                  }\n                };\n                data.mediaRecorder.stop();\n                data.isRecording = false;\n                const playButton = document.getElementById(\"playButton\");\n                if (playButton) playButton.innerHTML = window.micIconHTML;\n              }\n            }\n          });\n        }\n        \n        // Network status events - FIXED to use safeElement\n        window.addEventListener('online', function() {\n          console.log(\"Application back online, processing queue\");\n          try {\n            // Get a safe element for anvil calls\n            const safeElement = document.getElementById(\"stopButton\");\n            if (safeElement) {\n              anvil.call(safeElement, 'refresh_session_relay');\n              anvil.call(safeElement, 'process_audio_queue');\n            } else {\n              console.error(\"No safe element found for online event\");\n            }\n            \n            window.updateConnectionStatusIndicator(true);\n          } catch (e) {\n            console.error(\"Error handling online event:\", e);\n          }\n        });\n        \n        window.addEventListener('offline', function() {\n          console.log(\"Application offline, switching to offline mode\");\n          try {\n            // Get a safe element for anvil calls\n            const safeElement = document.getElementById(\"stopButton\");\n            if (safeElement) {\n              anvil.call(safeElement, 'update_offline_status');\n            } else {\n              console.error(\"No safe element found for offline event\");\n            }\n            window.updateConnectionStatusIndicator(false);\n          } catch (e) {\n            console.error(\"Error handling offline event:\", e);\n          }\n        });\n        \n        // Navigation tabs\n        const navTabs = document.querySelectorAll('.nav-tab');\n        navTabs.forEach(tab => {\n          tab.replaceWith(tab.cloneNode(true));\n        });\n        \n        const newNavTabs = document.querySelectorAll('.nav-tab');\n        newNavTabs.forEach(tab => {\n          tab.addEventListener('click', function(e) {\n            const tabName = this.getAttribute('data-tab');\n            if (tabName === 'Production') {\n              anvil.call(e.target, 'open_production_form');\n            } else if (tabName === 'Templates') {\n              anvil.call(e.target, 'open_templates_form');\n            } else if (tabName === 'Archives') {\n              anvil.call(e.target, 'open_archives_form');\n            } else if (tabName === 'Settings') {\n              anvil.call(e.target, 'open_settings_form');\n            }\n          });\n        });\n        \n        // Title Modal Events\n        const closeTitleModalBtn = document.getElementById(\"closeTitleModalBtn\");\n        if (closeTitleModalBtn) {\n          closeTitleModalBtn.replaceWith(closeTitleModalBtn.cloneNode(true));\n          const newCloseBtn = document.getElementById(\"closeTitleModalBtn\");\n          newCloseBtn.addEventListener('click', function() {\n            window.closeTitleModal();\n          });\n        }\n        \n        // Save title button\n        const saveTitleBtn = document.getElementById(\"saveTitleBtn\");\n        if (saveTitleBtn) {\n          saveTitleBtn.replaceWith(saveTitleBtn.cloneNode(true));\n          const newSaveBtn = document.getElementById(\"saveTitleBtn\");\n          newSaveBtn.addEventListener('click', function() {\n            window.saveRecordingTitle();\n          });\n        }\n        \n        // Handle Enter key in title input\n        const recordingTitle = document.getElementById(\"recordingTitle\");\n        if (recordingTitle) {\n          recordingTitle.replaceWith(recordingTitle.cloneNode(true));\n          const newTitleInput = document.getElementById(\"recordingTitle\");\n          \n          newTitleInput.addEventListener(\"keyup\", function(event) {\n            if (event.key === \"Enter\") {\n              window.saveRecordingTitle();\n            }\n          });\n        }\n        \n        // Wake lock request on load\n        window.wakeLockController.requestWakeLock();\n        \n        // Update queue display on startup\n        window.updateQueueDisplay();\n        \n        // Initial connection status check\n        const isOnline = window.getBrowserOnlineStatus();\n        window.updateConnectionStatusIndicator(isOnline);\n        \n        console.log(\"OfflineAudioManager: Event listeners attached. iOS detection:\", data.isIOS);\n      };\n      \n      // Reset the recording state if browser reloads\n      window.addEventListener('beforeunload', function() {\n        const data = window.audioManagerData;\n        if (data.stream) {\n          data.stream.getTracks().forEach(track => track.stop());\n        }\n        if (data.recordRTC) {\n          data.recordRTC.destroy();\n        }\n        window.wakeLockController.releaseWakeLock();\n      });\n    }\n    \n    // Attach all event listeners\n    window.__attachOfflineAudioManagerEvents();\n    \n    // Make sure queue display is updated on initial load\n    window.updateQueueDisplay();\n  </script>\n</body>\n</html>"
  type: HtmlTemplate
is_package: true
