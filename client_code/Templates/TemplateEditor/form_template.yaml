components:
- layout_properties: {slot: default}
  name: header_return_1
  properties: {return_form: Templates.Templates}
  type: form:Components.HeaderReturn
- layout_properties: {slot: editor_slot}
  name: text_editor_1
  properties: {show_align_buttons: true, show_image_button: false}
  type: form:Components.TextEditor
container:
  properties:
    html: |-
      <!DOCTYPE html>
      <html lang="fr">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Template Editor</title>
          <style>
            /* ===========================
            Basic Layout & Container
            ============================ */
            * {
              box-sizing: border-box;
              font-family: Arial, sans-serif;
              margin: 0;
              padding: 0;
            }
            body {
              background-color: #f5f5f5;
              height: 100vh;
              overflow: hidden;
            }
            .container {
              display: flex;
              flex-direction: column;
              height: 100vh;
              width: 100%;
              max-width: 800px;
              margin: 0 auto;
              background: #fff;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }

            /* ===========================
            Template Name Input
            ============================ */
            .template-name {
              padding: 15px 20px;
              border-bottom: 1px solid #ddd;
            }
            .template-name input {
              width: 100%;
              padding: 10px;
              border: 1px solid #ddd;
              border-radius: 4px;
              font-size: 16px;
            }

            /* ===========================
            Scrollable Content
            ============================ */
            .scrollable-content {
              flex: 1;
              overflow-y: auto;
              padding: 20px;
              padding-bottom: 80px; /* space for bottom buttons */
            }

            /* ===========================
            BOTTOM BUTTONS
            ============================ */
            .bottom-buttons {
              position: fixed;
              bottom: 0;
              left: 50%;
              transform: translateX(-50%);
              width: 800px;
              max-width: 100%;
              background: #fff;
              padding: 15px 20px;
              display: flex;
              justify-content: center;
              gap: 20px;
              border-top: 1px solid #ddd;
              box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
              z-index: 10;
            }
            .bottom-button {
              padding: 10px 30px;
              border: 1px solid #ddd;
              border-radius: 4px;
              background: #fff;
              cursor: pointer;
              font-size: 14px;
              transition: all 0.2s ease;
            }
            .bottom-button:hover {
              background: #f5f5f5;
              border-color: #999;
            }
            .primary-button {
              background: #4caf50;
              color: white;
              border-color: #4caf50;
            }
            .primary-button:hover {
              background: #45a049;
              border-color: #45a049;
            }

            /* ===========================
            NOTIFICATION BANNERS
            ============================ */
            #bannerContainer {
              position: fixed;
              top: 20px;
              left: 50%;
              transform: translateX(-50%);
              z-index: 2000;
            }
            .banner {
              margin-bottom: 10px;
              padding: 10px 20px;
              border-radius: 4px;
              color: #fff;
              opacity: 0.9;
              font-size: 14px;
              min-width: 200px;
              text-align: center;
              transition: opacity 0.3s ease;
            }
            .banner-success {
              background-color: #4caf50;
            }
            .banner-error {
              background-color: #f44336;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <!-- Return bar -->
            <div anvil-slot="default"></div>

            <!-- Template name input -->
            <div class="template-name">
              <input type="text" id="templateName" placeholder="Template Name">
            </div>

            <!-- Main scrollable area -->
            <div class="scrollable-content">
            <div anvil-slot="editor_slot"></div>

            <!-- Bottom buttons -->
            <div class="bottom-buttons">
              <button class="bottom-button" id="cancelButton">Cancel</button>
              <button class="bottom-button primary-button" id="saveButton">Save Template</button>
            </div>
          </div>

          <!-- Banner container -->
          <div id="bannerContainer"></div>

            <script>
              /****************************************************
           * 1) RULE 1: DEFINE GLOBALS & HELPERS ONLY ONCE
           ****************************************************/
              console.log("===== LOADING TEMPLATE EDITOR HTML/JS =====");

              // Use a guard to ensure functions exposed to Python and other globals
              // are defined only a single time.
              if (!window.__my_template_editor_globals) {
                window.__my_template_editor_globals = true;

                window.setTemplateNameValue = function(value) {
                  console.log("setTemplateNameValue() called in JS");
                  const nameInput = document.getElementById("templateName");
                  if (nameInput) {
                    nameInput.value = value || "";
                  } else {
                    // This warning is crucial for debugging race conditions.
                    // If it appears, the Python form_show fired before the DOM was ready.
                    console.warn("#templateName not found in setTemplateNameValue");
                  }
                };

                /***********************************************
             * Banner function (matching .py calls: displayBanner)
             ***********************************************/
                window.displayBanner = function(message, type) {
                  console.log("displayBanner() =>", message, type);
                  const container = document.getElementById("bannerContainer");
                  if (!container) {
                    console.warn("#bannerContainer not found!");
                    return;
                  }
                  const banner = document.createElement("div");
                  banner.className = "banner " + (type === "success" ? "banner-success" : "banner-error");
                  banner.textContent = message;
                  container.appendChild(banner);

                  // Auto-hide after 3s
                  setTimeout(() => {
                    banner.style.opacity = "0";
                    setTimeout(() => {
                      if (banner.parentNode) {
                        banner.parentNode.removeChild(banner);
                      }
                    }, 300);
                  }, 3000);
                };

                // Session refresh listeners also only need to be attached once.
                if (!window.__session_handlers_initialized) {
                  window.__session_handlers_initialized = true;
                  document.addEventListener("visibilitychange", () => {
                    if (document.visibilityState === "visible") {
                      // Use a valid element for the Anvil call
                      anvil.call(document.body, "refresh_session_relay");
                    }
                  });
                  window.addEventListener("online", () => {
                    anvil.call(document.body, "refresh_session_relay");
                  });
                }
              }


              /****************************************************
           * 2) RULE 2: ALWAYS ATTACH EVENT LISTENERS ON LOAD
           ****************************************************/
              // This function is defined outside the guard so it's always accessible.
              // It will attach (or re-attach) event listeners every time the form is shown.
              window.__attachTemplateEditorEvents = function() {
                console.log("===== Attaching Template Editor Event Listeners =====");

                // "Return" bar
                const returnBar = document.getElementById("returnBar");
                if (returnBar) {
                  // Use the cloneNode pattern to remove old listeners
                  returnBar.replaceWith(returnBar.cloneNode(true));
                  const newReturnBar = document.getElementById("returnBar");
                  newReturnBar.addEventListener("click", e => {
                    console.log("'Return' clicked => call return_clicked in Python");
                    // Use event.target per the rules
                    anvil.call(e.target, "return_clicked");
                  });
                }

                // Save button
                const saveButton = document.getElementById("saveButton");
                if (saveButton) {
                  saveButton.replaceWith(saveButton.cloneNode(true));
                  const newSaveButton = document.getElementById("saveButton");
                  newSaveButton.addEventListener("click", e => {
                    console.log("'Save Template' clicked => call save_template in Python");
                    const templateName = document.getElementById("templateName").value.trim();
                    if (!templateName) {
                      displayBanner("Please enter a template name", "error");
                      return;
                    }

                    // Assuming getEditorContent is a global function from your TextEditor component
                    const contentJSON = window.getEditorContent ? JSON.stringify({ content: window.getEditorContent() }) : '{}';
                    const images = []; // Your image extraction logic can go here

                    anvil.call(e.target, "save_template", templateName, contentJSON, images);
                  });
                }

                // Cancel button
                const cancelButton = document.getElementById("cancelButton");
                if (cancelButton) {
                  cancelButton.replaceWith(cancelButton.cloneNode(true));
                  const newCancelButton = document.getElementById("cancelButton");
                  newCancelButton.addEventListener("click", e => {
                    console.log("'Cancel' clicked => call return_clicked in Python");
                    anvil.call(e.target, "return_clicked");
                  });
                }

                console.log("===== Done attaching Template Editor event listeners =====");
              };


              /****************************************************
           * 3) RULE 3: IMMEDIATELY ATTACH EVERYTHING
           ****************************************************/
              // This call is now OUTSIDE the guard, so it runs on EVERY form load,
              // ensuring the event listeners are always attached to the current buttons.
              window.__attachTemplateEditorEvents();

              console.log("===== TEMPLATE EDITOR HTML/JS FULLY LOADED =====");
            </script>
        </body>
      </html>
  type: HtmlTemplate
is_package: true
